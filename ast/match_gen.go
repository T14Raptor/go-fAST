// Code generated by gen_match.go; DO NOT EDIT.
package ast

func matchAny(actual any, pattern any) bool {
	if pattern == nil {
		return true
	}
	switch p := pattern.(type) {
	case *Any:
		return true
	case *Capture:
		return bindCapture(actual, p.Out)
	case *ArrayLiteral:
		a, ok := actual.(*ArrayLiteral)
		if !ok {
			return false
		}
		return matchArrayLiteral(a, p)
	case ArrayLiteral:
		a, ok := actual.(ArrayLiteral)
		if !ok {
			return false
		}
		return matchArrayLiteral(&a, &p)
	case *ArrayPattern:
		a, ok := actual.(*ArrayPattern)
		if !ok {
			return false
		}
		return matchArrayPattern(a, p)
	case ArrayPattern:
		a, ok := actual.(ArrayPattern)
		if !ok {
			return false
		}
		return matchArrayPattern(&a, &p)
	case *ArrowFunctionLiteral:
		a, ok := actual.(*ArrowFunctionLiteral)
		if !ok {
			return false
		}
		return matchArrowFunctionLiteral(a, p)
	case ArrowFunctionLiteral:
		a, ok := actual.(ArrowFunctionLiteral)
		if !ok {
			return false
		}
		return matchArrowFunctionLiteral(&a, &p)
	case *AssignExpression:
		a, ok := actual.(*AssignExpression)
		if !ok {
			return false
		}
		return matchAssignExpression(a, p)
	case AssignExpression:
		a, ok := actual.(AssignExpression)
		if !ok {
			return false
		}
		return matchAssignExpression(&a, &p)
	case *AwaitExpression:
		a, ok := actual.(*AwaitExpression)
		if !ok {
			return false
		}
		return matchAwaitExpression(a, p)
	case AwaitExpression:
		a, ok := actual.(AwaitExpression)
		if !ok {
			return false
		}
		return matchAwaitExpression(&a, &p)
	case *BadStatement:
		a, ok := actual.(*BadStatement)
		if !ok {
			return false
		}
		return matchBadStatement(a, p)
	case BadStatement:
		a, ok := actual.(BadStatement)
		if !ok {
			return false
		}
		return matchBadStatement(&a, &p)
	case *BinaryExpression:
		a, ok := actual.(*BinaryExpression)
		if !ok {
			return false
		}
		return matchBinaryExpression(a, p)
	case BinaryExpression:
		a, ok := actual.(BinaryExpression)
		if !ok {
			return false
		}
		return matchBinaryExpression(&a, &p)
	case *BindingTarget:
		a, ok := actual.(*BindingTarget)
		if !ok {
			return false
		}
		return matchBindingTarget(a, p)
	case BindingTarget:
		a, ok := actual.(BindingTarget)
		if !ok {
			return false
		}
		return matchBindingTarget(&a, &p)
	case *BlockStatement:
		a, ok := actual.(*BlockStatement)
		if !ok {
			return false
		}
		return matchBlockStatement(a, p)
	case BlockStatement:
		a, ok := actual.(BlockStatement)
		if !ok {
			return false
		}
		return matchBlockStatement(&a, &p)
	case *BooleanLiteral:
		a, ok := actual.(*BooleanLiteral)
		if !ok {
			return false
		}
		return matchBooleanLiteral(a, p)
	case BooleanLiteral:
		a, ok := actual.(BooleanLiteral)
		if !ok {
			return false
		}
		return matchBooleanLiteral(&a, &p)
	case *BreakStatement:
		a, ok := actual.(*BreakStatement)
		if !ok {
			return false
		}
		return matchBreakStatement(a, p)
	case BreakStatement:
		a, ok := actual.(BreakStatement)
		if !ok {
			return false
		}
		return matchBreakStatement(&a, &p)
	case *CallExpression:
		a, ok := actual.(*CallExpression)
		if !ok {
			return false
		}
		return matchCallExpression(a, p)
	case CallExpression:
		a, ok := actual.(CallExpression)
		if !ok {
			return false
		}
		return matchCallExpression(&a, &p)
	case *CaseStatement:
		a, ok := actual.(*CaseStatement)
		if !ok {
			return false
		}
		return matchCaseStatement(a, p)
	case CaseStatement:
		a, ok := actual.(CaseStatement)
		if !ok {
			return false
		}
		return matchCaseStatement(&a, &p)
	case *CatchStatement:
		a, ok := actual.(*CatchStatement)
		if !ok {
			return false
		}
		return matchCatchStatement(a, p)
	case CatchStatement:
		a, ok := actual.(CatchStatement)
		if !ok {
			return false
		}
		return matchCatchStatement(&a, &p)
	case *ClassDeclaration:
		a, ok := actual.(*ClassDeclaration)
		if !ok {
			return false
		}
		return matchClassDeclaration(a, p)
	case ClassDeclaration:
		a, ok := actual.(ClassDeclaration)
		if !ok {
			return false
		}
		return matchClassDeclaration(&a, &p)
	case *ClassElement:
		a, ok := actual.(*ClassElement)
		if !ok {
			return false
		}
		return matchClassElement(a, p)
	case ClassElement:
		a, ok := actual.(ClassElement)
		if !ok {
			return false
		}
		return matchClassElement(&a, &p)
	case *ClassLiteral:
		a, ok := actual.(*ClassLiteral)
		if !ok {
			return false
		}
		return matchClassLiteral(a, p)
	case ClassLiteral:
		a, ok := actual.(ClassLiteral)
		if !ok {
			return false
		}
		return matchClassLiteral(&a, &p)
	case *ClassStaticBlock:
		a, ok := actual.(*ClassStaticBlock)
		if !ok {
			return false
		}
		return matchClassStaticBlock(a, p)
	case ClassStaticBlock:
		a, ok := actual.(ClassStaticBlock)
		if !ok {
			return false
		}
		return matchClassStaticBlock(&a, &p)
	case *ComputedProperty:
		a, ok := actual.(*ComputedProperty)
		if !ok {
			return false
		}
		return matchComputedProperty(a, p)
	case ComputedProperty:
		a, ok := actual.(ComputedProperty)
		if !ok {
			return false
		}
		return matchComputedProperty(&a, &p)
	case *ConciseBody:
		a, ok := actual.(*ConciseBody)
		if !ok {
			return false
		}
		return matchConciseBody(a, p)
	case ConciseBody:
		a, ok := actual.(ConciseBody)
		if !ok {
			return false
		}
		return matchConciseBody(&a, &p)
	case *ConditionalExpression:
		a, ok := actual.(*ConditionalExpression)
		if !ok {
			return false
		}
		return matchConditionalExpression(a, p)
	case ConditionalExpression:
		a, ok := actual.(ConditionalExpression)
		if !ok {
			return false
		}
		return matchConditionalExpression(&a, &p)
	case *ContinueStatement:
		a, ok := actual.(*ContinueStatement)
		if !ok {
			return false
		}
		return matchContinueStatement(a, p)
	case ContinueStatement:
		a, ok := actual.(ContinueStatement)
		if !ok {
			return false
		}
		return matchContinueStatement(&a, &p)
	case *DebuggerStatement:
		a, ok := actual.(*DebuggerStatement)
		if !ok {
			return false
		}
		return matchDebuggerStatement(a, p)
	case DebuggerStatement:
		a, ok := actual.(DebuggerStatement)
		if !ok {
			return false
		}
		return matchDebuggerStatement(&a, &p)
	case *DoWhileStatement:
		a, ok := actual.(*DoWhileStatement)
		if !ok {
			return false
		}
		return matchDoWhileStatement(a, p)
	case DoWhileStatement:
		a, ok := actual.(DoWhileStatement)
		if !ok {
			return false
		}
		return matchDoWhileStatement(&a, &p)
	case *EmptyStatement:
		a, ok := actual.(*EmptyStatement)
		if !ok {
			return false
		}
		return matchEmptyStatement(a, p)
	case EmptyStatement:
		a, ok := actual.(EmptyStatement)
		if !ok {
			return false
		}
		return matchEmptyStatement(&a, &p)
	case *Expression:
		a, ok := actual.(*Expression)
		if !ok {
			return false
		}
		return matchExpression(a, p)
	case Expression:
		a, ok := actual.(Expression)
		if !ok {
			return false
		}
		return matchExpression(&a, &p)
	case *ExpressionStatement:
		a, ok := actual.(*ExpressionStatement)
		if !ok {
			return false
		}
		return matchExpressionStatement(a, p)
	case ExpressionStatement:
		a, ok := actual.(ExpressionStatement)
		if !ok {
			return false
		}
		return matchExpressionStatement(&a, &p)
	case *FieldDefinition:
		a, ok := actual.(*FieldDefinition)
		if !ok {
			return false
		}
		return matchFieldDefinition(a, p)
	case FieldDefinition:
		a, ok := actual.(FieldDefinition)
		if !ok {
			return false
		}
		return matchFieldDefinition(&a, &p)
	case *ForInStatement:
		a, ok := actual.(*ForInStatement)
		if !ok {
			return false
		}
		return matchForInStatement(a, p)
	case ForInStatement:
		a, ok := actual.(ForInStatement)
		if !ok {
			return false
		}
		return matchForInStatement(&a, &p)
	case *ForInto:
		a, ok := actual.(*ForInto)
		if !ok {
			return false
		}
		return matchForInto(a, p)
	case ForInto:
		a, ok := actual.(ForInto)
		if !ok {
			return false
		}
		return matchForInto(&a, &p)
	case *ForLoopInitializer:
		a, ok := actual.(*ForLoopInitializer)
		if !ok {
			return false
		}
		return matchForLoopInitializer(a, p)
	case ForLoopInitializer:
		a, ok := actual.(ForLoopInitializer)
		if !ok {
			return false
		}
		return matchForLoopInitializer(&a, &p)
	case *ForOfStatement:
		a, ok := actual.(*ForOfStatement)
		if !ok {
			return false
		}
		return matchForOfStatement(a, p)
	case ForOfStatement:
		a, ok := actual.(ForOfStatement)
		if !ok {
			return false
		}
		return matchForOfStatement(&a, &p)
	case *ForStatement:
		a, ok := actual.(*ForStatement)
		if !ok {
			return false
		}
		return matchForStatement(a, p)
	case ForStatement:
		a, ok := actual.(ForStatement)
		if !ok {
			return false
		}
		return matchForStatement(&a, &p)
	case *FunctionDeclaration:
		a, ok := actual.(*FunctionDeclaration)
		if !ok {
			return false
		}
		return matchFunctionDeclaration(a, p)
	case FunctionDeclaration:
		a, ok := actual.(FunctionDeclaration)
		if !ok {
			return false
		}
		return matchFunctionDeclaration(&a, &p)
	case *FunctionLiteral:
		a, ok := actual.(*FunctionLiteral)
		if !ok {
			return false
		}
		return matchFunctionLiteral(a, p)
	case FunctionLiteral:
		a, ok := actual.(FunctionLiteral)
		if !ok {
			return false
		}
		return matchFunctionLiteral(&a, &p)
	case *Identifier:
		a, ok := actual.(*Identifier)
		if !ok {
			return false
		}
		return matchIdentifier(a, p)
	case Identifier:
		a, ok := actual.(Identifier)
		if !ok {
			return false
		}
		return matchIdentifier(&a, &p)
	case *IfStatement:
		a, ok := actual.(*IfStatement)
		if !ok {
			return false
		}
		return matchIfStatement(a, p)
	case IfStatement:
		a, ok := actual.(IfStatement)
		if !ok {
			return false
		}
		return matchIfStatement(&a, &p)
	case *InvalidExpression:
		a, ok := actual.(*InvalidExpression)
		if !ok {
			return false
		}
		return matchInvalidExpression(a, p)
	case InvalidExpression:
		a, ok := actual.(InvalidExpression)
		if !ok {
			return false
		}
		return matchInvalidExpression(&a, &p)
	case *LabelledStatement:
		a, ok := actual.(*LabelledStatement)
		if !ok {
			return false
		}
		return matchLabelledStatement(a, p)
	case LabelledStatement:
		a, ok := actual.(LabelledStatement)
		if !ok {
			return false
		}
		return matchLabelledStatement(&a, &p)
	case *MemberExpression:
		a, ok := actual.(*MemberExpression)
		if !ok {
			return false
		}
		return matchMemberExpression(a, p)
	case MemberExpression:
		a, ok := actual.(MemberExpression)
		if !ok {
			return false
		}
		return matchMemberExpression(&a, &p)
	case *MemberProperty:
		a, ok := actual.(*MemberProperty)
		if !ok {
			return false
		}
		return matchMemberProperty(a, p)
	case MemberProperty:
		a, ok := actual.(MemberProperty)
		if !ok {
			return false
		}
		return matchMemberProperty(&a, &p)
	case *MetaProperty:
		a, ok := actual.(*MetaProperty)
		if !ok {
			return false
		}
		return matchMetaProperty(a, p)
	case MetaProperty:
		a, ok := actual.(MetaProperty)
		if !ok {
			return false
		}
		return matchMetaProperty(&a, &p)
	case *MethodDefinition:
		a, ok := actual.(*MethodDefinition)
		if !ok {
			return false
		}
		return matchMethodDefinition(a, p)
	case MethodDefinition:
		a, ok := actual.(MethodDefinition)
		if !ok {
			return false
		}
		return matchMethodDefinition(&a, &p)
	case *NewExpression:
		a, ok := actual.(*NewExpression)
		if !ok {
			return false
		}
		return matchNewExpression(a, p)
	case NewExpression:
		a, ok := actual.(NewExpression)
		if !ok {
			return false
		}
		return matchNewExpression(&a, &p)
	case *NullLiteral:
		a, ok := actual.(*NullLiteral)
		if !ok {
			return false
		}
		return matchNullLiteral(a, p)
	case NullLiteral:
		a, ok := actual.(NullLiteral)
		if !ok {
			return false
		}
		return matchNullLiteral(&a, &p)
	case *NumberLiteral:
		a, ok := actual.(*NumberLiteral)
		if !ok {
			return false
		}
		return matchNumberLiteral(a, p)
	case NumberLiteral:
		a, ok := actual.(NumberLiteral)
		if !ok {
			return false
		}
		return matchNumberLiteral(&a, &p)
	case *ObjectLiteral:
		a, ok := actual.(*ObjectLiteral)
		if !ok {
			return false
		}
		return matchObjectLiteral(a, p)
	case ObjectLiteral:
		a, ok := actual.(ObjectLiteral)
		if !ok {
			return false
		}
		return matchObjectLiteral(&a, &p)
	case *ObjectPattern:
		a, ok := actual.(*ObjectPattern)
		if !ok {
			return false
		}
		return matchObjectPattern(a, p)
	case ObjectPattern:
		a, ok := actual.(ObjectPattern)
		if !ok {
			return false
		}
		return matchObjectPattern(&a, &p)
	case *Optional:
		a, ok := actual.(*Optional)
		if !ok {
			return false
		}
		return matchOptional(a, p)
	case Optional:
		a, ok := actual.(Optional)
		if !ok {
			return false
		}
		return matchOptional(&a, &p)
	case *OptionalChain:
		a, ok := actual.(*OptionalChain)
		if !ok {
			return false
		}
		return matchOptionalChain(a, p)
	case OptionalChain:
		a, ok := actual.(OptionalChain)
		if !ok {
			return false
		}
		return matchOptionalChain(&a, &p)
	case *ParameterList:
		a, ok := actual.(*ParameterList)
		if !ok {
			return false
		}
		return matchParameterList(a, p)
	case ParameterList:
		a, ok := actual.(ParameterList)
		if !ok {
			return false
		}
		return matchParameterList(&a, &p)
	case *PrivateDotExpression:
		a, ok := actual.(*PrivateDotExpression)
		if !ok {
			return false
		}
		return matchPrivateDotExpression(a, p)
	case PrivateDotExpression:
		a, ok := actual.(PrivateDotExpression)
		if !ok {
			return false
		}
		return matchPrivateDotExpression(&a, &p)
	case *PrivateIdentifier:
		a, ok := actual.(*PrivateIdentifier)
		if !ok {
			return false
		}
		return matchPrivateIdentifier(a, p)
	case PrivateIdentifier:
		a, ok := actual.(PrivateIdentifier)
		if !ok {
			return false
		}
		return matchPrivateIdentifier(&a, &p)
	case *Program:
		a, ok := actual.(*Program)
		if !ok {
			return false
		}
		return matchProgram(a, p)
	case Program:
		a, ok := actual.(Program)
		if !ok {
			return false
		}
		return matchProgram(&a, &p)
	case *Property:
		a, ok := actual.(*Property)
		if !ok {
			return false
		}
		return matchProperty(a, p)
	case Property:
		a, ok := actual.(Property)
		if !ok {
			return false
		}
		return matchProperty(&a, &p)
	case *PropertyKeyed:
		a, ok := actual.(*PropertyKeyed)
		if !ok {
			return false
		}
		return matchPropertyKeyed(a, p)
	case PropertyKeyed:
		a, ok := actual.(PropertyKeyed)
		if !ok {
			return false
		}
		return matchPropertyKeyed(&a, &p)
	case *PropertyShort:
		a, ok := actual.(*PropertyShort)
		if !ok {
			return false
		}
		return matchPropertyShort(a, p)
	case PropertyShort:
		a, ok := actual.(PropertyShort)
		if !ok {
			return false
		}
		return matchPropertyShort(&a, &p)
	case *RegExpLiteral:
		a, ok := actual.(*RegExpLiteral)
		if !ok {
			return false
		}
		return matchRegExpLiteral(a, p)
	case RegExpLiteral:
		a, ok := actual.(RegExpLiteral)
		if !ok {
			return false
		}
		return matchRegExpLiteral(&a, &p)
	case *ReturnStatement:
		a, ok := actual.(*ReturnStatement)
		if !ok {
			return false
		}
		return matchReturnStatement(a, p)
	case ReturnStatement:
		a, ok := actual.(ReturnStatement)
		if !ok {
			return false
		}
		return matchReturnStatement(&a, &p)
	case *SequenceExpression:
		a, ok := actual.(*SequenceExpression)
		if !ok {
			return false
		}
		return matchSequenceExpression(a, p)
	case SequenceExpression:
		a, ok := actual.(SequenceExpression)
		if !ok {
			return false
		}
		return matchSequenceExpression(&a, &p)
	case *SpreadElement:
		a, ok := actual.(*SpreadElement)
		if !ok {
			return false
		}
		return matchSpreadElement(a, p)
	case SpreadElement:
		a, ok := actual.(SpreadElement)
		if !ok {
			return false
		}
		return matchSpreadElement(&a, &p)
	case *Statement:
		a, ok := actual.(*Statement)
		if !ok {
			return false
		}
		return matchStatement(a, p)
	case Statement:
		a, ok := actual.(Statement)
		if !ok {
			return false
		}
		return matchStatement(&a, &p)
	case *StringLiteral:
		a, ok := actual.(*StringLiteral)
		if !ok {
			return false
		}
		return matchStringLiteral(a, p)
	case StringLiteral:
		a, ok := actual.(StringLiteral)
		if !ok {
			return false
		}
		return matchStringLiteral(&a, &p)
	case *SuperExpression:
		a, ok := actual.(*SuperExpression)
		if !ok {
			return false
		}
		return matchSuperExpression(a, p)
	case SuperExpression:
		a, ok := actual.(SuperExpression)
		if !ok {
			return false
		}
		return matchSuperExpression(&a, &p)
	case *SwitchStatement:
		a, ok := actual.(*SwitchStatement)
		if !ok {
			return false
		}
		return matchSwitchStatement(a, p)
	case SwitchStatement:
		a, ok := actual.(SwitchStatement)
		if !ok {
			return false
		}
		return matchSwitchStatement(&a, &p)
	case *TemplateElement:
		a, ok := actual.(*TemplateElement)
		if !ok {
			return false
		}
		return matchTemplateElement(a, p)
	case TemplateElement:
		a, ok := actual.(TemplateElement)
		if !ok {
			return false
		}
		return matchTemplateElement(&a, &p)
	case *TemplateLiteral:
		a, ok := actual.(*TemplateLiteral)
		if !ok {
			return false
		}
		return matchTemplateLiteral(a, p)
	case TemplateLiteral:
		a, ok := actual.(TemplateLiteral)
		if !ok {
			return false
		}
		return matchTemplateLiteral(&a, &p)
	case *ThisExpression:
		a, ok := actual.(*ThisExpression)
		if !ok {
			return false
		}
		return matchThisExpression(a, p)
	case ThisExpression:
		a, ok := actual.(ThisExpression)
		if !ok {
			return false
		}
		return matchThisExpression(&a, &p)
	case *ThrowStatement:
		a, ok := actual.(*ThrowStatement)
		if !ok {
			return false
		}
		return matchThrowStatement(a, p)
	case ThrowStatement:
		a, ok := actual.(ThrowStatement)
		if !ok {
			return false
		}
		return matchThrowStatement(&a, &p)
	case *TryStatement:
		a, ok := actual.(*TryStatement)
		if !ok {
			return false
		}
		return matchTryStatement(a, p)
	case TryStatement:
		a, ok := actual.(TryStatement)
		if !ok {
			return false
		}
		return matchTryStatement(&a, &p)
	case *UnaryExpression:
		a, ok := actual.(*UnaryExpression)
		if !ok {
			return false
		}
		return matchUnaryExpression(a, p)
	case UnaryExpression:
		a, ok := actual.(UnaryExpression)
		if !ok {
			return false
		}
		return matchUnaryExpression(&a, &p)
	case *UpdateExpression:
		a, ok := actual.(*UpdateExpression)
		if !ok {
			return false
		}
		return matchUpdateExpression(a, p)
	case UpdateExpression:
		a, ok := actual.(UpdateExpression)
		if !ok {
			return false
		}
		return matchUpdateExpression(&a, &p)
	case *VariableDeclaration:
		a, ok := actual.(*VariableDeclaration)
		if !ok {
			return false
		}
		return matchVariableDeclaration(a, p)
	case VariableDeclaration:
		a, ok := actual.(VariableDeclaration)
		if !ok {
			return false
		}
		return matchVariableDeclaration(&a, &p)
	case *VariableDeclarator:
		a, ok := actual.(*VariableDeclarator)
		if !ok {
			return false
		}
		return matchVariableDeclarator(a, p)
	case VariableDeclarator:
		a, ok := actual.(VariableDeclarator)
		if !ok {
			return false
		}
		return matchVariableDeclarator(&a, &p)
	case *WhileStatement:
		a, ok := actual.(*WhileStatement)
		if !ok {
			return false
		}
		return matchWhileStatement(a, p)
	case WhileStatement:
		a, ok := actual.(WhileStatement)
		if !ok {
			return false
		}
		return matchWhileStatement(&a, &p)
	case *WithStatement:
		a, ok := actual.(*WithStatement)
		if !ok {
			return false
		}
		return matchWithStatement(a, p)
	case WithStatement:
		a, ok := actual.(WithStatement)
		if !ok {
			return false
		}
		return matchWithStatement(&a, &p)
	case *YieldExpression:
		a, ok := actual.(*YieldExpression)
		if !ok {
			return false
		}
		return matchYieldExpression(a, p)
	case YieldExpression:
		a, ok := actual.(YieldExpression)
		if !ok {
			return false
		}
		return matchYieldExpression(&a, &p)
	case CaseStatements:
		a, ok := actual.(CaseStatements)
		if !ok {
			return false
		}
		return matchCaseStatements(a, p)
	case ClassElements:
		a, ok := actual.(ClassElements)
		if !ok {
			return false
		}
		return matchClassElements(a, p)
	case Expressions:
		a, ok := actual.(Expressions)
		if !ok {
			return false
		}
		return matchExpressions(a, p)
	case Properties:
		a, ok := actual.(Properties)
		if !ok {
			return false
		}
		return matchProperties(a, p)
	case Statements:
		a, ok := actual.(Statements)
		if !ok {
			return false
		}
		return matchStatements(a, p)
	case TemplateElements:
		a, ok := actual.(TemplateElements)
		if !ok {
			return false
		}
		return matchTemplateElements(a, p)
	case VariableDeclarators:
		a, ok := actual.(VariableDeclarators)
		if !ok {
			return false
		}
		return matchVariableDeclarators(a, p)
	case Body:
		a, ok := actual.(Body)
		if !ok {
			return false
		}
		return matchBody(a, p)
	case Element:
		a, ok := actual.(Element)
		if !ok {
			return false
		}
		return matchElement(a, p)
	case Expr:
		a, ok := actual.(Expr)
		if !ok {
			return false
		}
		return matchExpr(a, p)
	case ForLoopInit:
		a, ok := actual.(ForLoopInit)
		if !ok {
			return false
		}
		return matchForLoopInit(a, p)
	case Into:
		a, ok := actual.(Into)
		if !ok {
			return false
		}
		return matchInto(a, p)
	case MemberProp:
		a, ok := actual.(MemberProp)
		if !ok {
			return false
		}
		return matchMemberProp(a, p)
	case Pattern:
		a, ok := actual.(Pattern)
		if !ok {
			return false
		}
		return matchPattern(a, p)
	case Prop:
		a, ok := actual.(Prop)
		if !ok {
			return false
		}
		return matchProp(a, p)
	case Stmt:
		a, ok := actual.(Stmt)
		if !ok {
			return false
		}
		return matchStmt(a, p)
	case Target:
		a, ok := actual.(Target)
		if !ok {
			return false
		}
		return matchTarget(a, p)
	default:
		return false
	}
}

func bindCapture(actual any, out any) bool {
	switch dst := out.(type) {
	case **ArrayLiteral:
		v, ok := actual.(*ArrayLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ArrayPattern:
		v, ok := actual.(*ArrayPattern)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ArrowFunctionLiteral:
		v, ok := actual.(*ArrowFunctionLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **AssignExpression:
		v, ok := actual.(*AssignExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **AwaitExpression:
		v, ok := actual.(*AwaitExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **BadStatement:
		v, ok := actual.(*BadStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **BinaryExpression:
		v, ok := actual.(*BinaryExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **BindingTarget:
		v, ok := actual.(*BindingTarget)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **BlockStatement:
		v, ok := actual.(*BlockStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **BooleanLiteral:
		v, ok := actual.(*BooleanLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **BreakStatement:
		v, ok := actual.(*BreakStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **CallExpression:
		v, ok := actual.(*CallExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **CaseStatement:
		v, ok := actual.(*CaseStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **CatchStatement:
		v, ok := actual.(*CatchStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ClassDeclaration:
		v, ok := actual.(*ClassDeclaration)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ClassElement:
		v, ok := actual.(*ClassElement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ClassLiteral:
		v, ok := actual.(*ClassLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ClassStaticBlock:
		v, ok := actual.(*ClassStaticBlock)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ComputedProperty:
		v, ok := actual.(*ComputedProperty)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ConciseBody:
		v, ok := actual.(*ConciseBody)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ConditionalExpression:
		v, ok := actual.(*ConditionalExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ContinueStatement:
		v, ok := actual.(*ContinueStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **DebuggerStatement:
		v, ok := actual.(*DebuggerStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **DoWhileStatement:
		v, ok := actual.(*DoWhileStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **EmptyStatement:
		v, ok := actual.(*EmptyStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **Expression:
		v, ok := actual.(*Expression)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ExpressionStatement:
		v, ok := actual.(*ExpressionStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **FieldDefinition:
		v, ok := actual.(*FieldDefinition)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ForInStatement:
		v, ok := actual.(*ForInStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ForInto:
		v, ok := actual.(*ForInto)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ForLoopInitializer:
		v, ok := actual.(*ForLoopInitializer)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ForOfStatement:
		v, ok := actual.(*ForOfStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ForStatement:
		v, ok := actual.(*ForStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **FunctionDeclaration:
		v, ok := actual.(*FunctionDeclaration)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **FunctionLiteral:
		v, ok := actual.(*FunctionLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **Identifier:
		v, ok := actual.(*Identifier)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **IfStatement:
		v, ok := actual.(*IfStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **InvalidExpression:
		v, ok := actual.(*InvalidExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **LabelledStatement:
		v, ok := actual.(*LabelledStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **MemberExpression:
		v, ok := actual.(*MemberExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **MemberProperty:
		v, ok := actual.(*MemberProperty)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **MetaProperty:
		v, ok := actual.(*MetaProperty)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **MethodDefinition:
		v, ok := actual.(*MethodDefinition)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **NewExpression:
		v, ok := actual.(*NewExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **NullLiteral:
		v, ok := actual.(*NullLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **NumberLiteral:
		v, ok := actual.(*NumberLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ObjectLiteral:
		v, ok := actual.(*ObjectLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ObjectPattern:
		v, ok := actual.(*ObjectPattern)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **Optional:
		v, ok := actual.(*Optional)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **OptionalChain:
		v, ok := actual.(*OptionalChain)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ParameterList:
		v, ok := actual.(*ParameterList)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **PrivateDotExpression:
		v, ok := actual.(*PrivateDotExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **PrivateIdentifier:
		v, ok := actual.(*PrivateIdentifier)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **Program:
		v, ok := actual.(*Program)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **Property:
		v, ok := actual.(*Property)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **PropertyKeyed:
		v, ok := actual.(*PropertyKeyed)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **PropertyShort:
		v, ok := actual.(*PropertyShort)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **RegExpLiteral:
		v, ok := actual.(*RegExpLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ReturnStatement:
		v, ok := actual.(*ReturnStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **SequenceExpression:
		v, ok := actual.(*SequenceExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **SpreadElement:
		v, ok := actual.(*SpreadElement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **Statement:
		v, ok := actual.(*Statement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **StringLiteral:
		v, ok := actual.(*StringLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **SuperExpression:
		v, ok := actual.(*SuperExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **SwitchStatement:
		v, ok := actual.(*SwitchStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **TemplateElement:
		v, ok := actual.(*TemplateElement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **TemplateLiteral:
		v, ok := actual.(*TemplateLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ThisExpression:
		v, ok := actual.(*ThisExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **ThrowStatement:
		v, ok := actual.(*ThrowStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **TryStatement:
		v, ok := actual.(*TryStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **UnaryExpression:
		v, ok := actual.(*UnaryExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **UpdateExpression:
		v, ok := actual.(*UpdateExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **VariableDeclaration:
		v, ok := actual.(*VariableDeclaration)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **VariableDeclarator:
		v, ok := actual.(*VariableDeclarator)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **WhileStatement:
		v, ok := actual.(*WhileStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **WithStatement:
		v, ok := actual.(*WithStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	case **YieldExpression:
		v, ok := actual.(*YieldExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	default:
		return false
	}
}

func matchBody(a, p Body) bool {
	if p == nil {
		return true
	}
	if a == nil {
		return false
	}
	switch p := p.(type) {
	case *BlockStatement:
		aa, ok := a.(*BlockStatement)
		if !ok {
			return false
		}
		return matchBlockStatement(aa, p)
	case *Expression:
		aa, ok := a.(*Expression)
		if !ok {
			return false
		}
		return matchExpression(aa, p)
	default:
		return false
	}
}

func matchElement(a, p Element) bool {
	if p == nil {
		return true
	}
	if a == nil {
		return false
	}
	switch p := p.(type) {
	case *ClassStaticBlock:
		aa, ok := a.(*ClassStaticBlock)
		if !ok {
			return false
		}
		return matchClassStaticBlock(aa, p)
	case *FieldDefinition:
		aa, ok := a.(*FieldDefinition)
		if !ok {
			return false
		}
		return matchFieldDefinition(aa, p)
	case *MethodDefinition:
		aa, ok := a.(*MethodDefinition)
		if !ok {
			return false
		}
		return matchMethodDefinition(aa, p)
	default:
		return false
	}
}

func matchExpr(a, p Expr) bool {
	if p == nil {
		return true
	}
	if a == nil {
		return false
	}
	switch p := p.(type) {
	case *Any:
		return true
	case *Capture:
		return bindCapture(a, p.Out)
	case *ArrayLiteral:
		aa, ok := a.(*ArrayLiteral)
		if !ok {
			return false
		}
		return matchArrayLiteral(aa, p)
	case *ArrayPattern:
		aa, ok := a.(*ArrayPattern)
		if !ok {
			return false
		}
		return matchArrayPattern(aa, p)
	case *ArrowFunctionLiteral:
		aa, ok := a.(*ArrowFunctionLiteral)
		if !ok {
			return false
		}
		return matchArrowFunctionLiteral(aa, p)
	case *AssignExpression:
		aa, ok := a.(*AssignExpression)
		if !ok {
			return false
		}
		return matchAssignExpression(aa, p)
	case *AwaitExpression:
		aa, ok := a.(*AwaitExpression)
		if !ok {
			return false
		}
		return matchAwaitExpression(aa, p)
	case *BinaryExpression:
		aa, ok := a.(*BinaryExpression)
		if !ok {
			return false
		}
		return matchBinaryExpression(aa, p)
	case *BooleanLiteral:
		aa, ok := a.(*BooleanLiteral)
		if !ok {
			return false
		}
		return matchBooleanLiteral(aa, p)
	case *CallExpression:
		aa, ok := a.(*CallExpression)
		if !ok {
			return false
		}
		return matchCallExpression(aa, p)
	case *ClassLiteral:
		aa, ok := a.(*ClassLiteral)
		if !ok {
			return false
		}
		return matchClassLiteral(aa, p)
	case *ConditionalExpression:
		aa, ok := a.(*ConditionalExpression)
		if !ok {
			return false
		}
		return matchConditionalExpression(aa, p)
	case *FunctionLiteral:
		aa, ok := a.(*FunctionLiteral)
		if !ok {
			return false
		}
		return matchFunctionLiteral(aa, p)
	case *Identifier:
		aa, ok := a.(*Identifier)
		if !ok {
			return false
		}
		return matchIdentifier(aa, p)
	case *InvalidExpression:
		aa, ok := a.(*InvalidExpression)
		if !ok {
			return false
		}
		return matchInvalidExpression(aa, p)
	case *MemberExpression:
		aa, ok := a.(*MemberExpression)
		if !ok {
			return false
		}
		return matchMemberExpression(aa, p)
	case *MetaProperty:
		aa, ok := a.(*MetaProperty)
		if !ok {
			return false
		}
		return matchMetaProperty(aa, p)
	case *NewExpression:
		aa, ok := a.(*NewExpression)
		if !ok {
			return false
		}
		return matchNewExpression(aa, p)
	case *NullLiteral:
		aa, ok := a.(*NullLiteral)
		if !ok {
			return false
		}
		return matchNullLiteral(aa, p)
	case *NumberLiteral:
		aa, ok := a.(*NumberLiteral)
		if !ok {
			return false
		}
		return matchNumberLiteral(aa, p)
	case *ObjectLiteral:
		aa, ok := a.(*ObjectLiteral)
		if !ok {
			return false
		}
		return matchObjectLiteral(aa, p)
	case *ObjectPattern:
		aa, ok := a.(*ObjectPattern)
		if !ok {
			return false
		}
		return matchObjectPattern(aa, p)
	case *Optional:
		aa, ok := a.(*Optional)
		if !ok {
			return false
		}
		return matchOptional(aa, p)
	case *OptionalChain:
		aa, ok := a.(*OptionalChain)
		if !ok {
			return false
		}
		return matchOptionalChain(aa, p)
	case *PrivateDotExpression:
		aa, ok := a.(*PrivateDotExpression)
		if !ok {
			return false
		}
		return matchPrivateDotExpression(aa, p)
	case *PrivateIdentifier:
		aa, ok := a.(*PrivateIdentifier)
		if !ok {
			return false
		}
		return matchPrivateIdentifier(aa, p)
	case *PropertyKeyed:
		aa, ok := a.(*PropertyKeyed)
		if !ok {
			return false
		}
		return matchPropertyKeyed(aa, p)
	case *PropertyShort:
		aa, ok := a.(*PropertyShort)
		if !ok {
			return false
		}
		return matchPropertyShort(aa, p)
	case *RegExpLiteral:
		aa, ok := a.(*RegExpLiteral)
		if !ok {
			return false
		}
		return matchRegExpLiteral(aa, p)
	case *SequenceExpression:
		aa, ok := a.(*SequenceExpression)
		if !ok {
			return false
		}
		return matchSequenceExpression(aa, p)
	case *SpreadElement:
		aa, ok := a.(*SpreadElement)
		if !ok {
			return false
		}
		return matchSpreadElement(aa, p)
	case *StringLiteral:
		aa, ok := a.(*StringLiteral)
		if !ok {
			return false
		}
		return matchStringLiteral(aa, p)
	case *SuperExpression:
		aa, ok := a.(*SuperExpression)
		if !ok {
			return false
		}
		return matchSuperExpression(aa, p)
	case *TemplateLiteral:
		aa, ok := a.(*TemplateLiteral)
		if !ok {
			return false
		}
		return matchTemplateLiteral(aa, p)
	case *ThisExpression:
		aa, ok := a.(*ThisExpression)
		if !ok {
			return false
		}
		return matchThisExpression(aa, p)
	case *UnaryExpression:
		aa, ok := a.(*UnaryExpression)
		if !ok {
			return false
		}
		return matchUnaryExpression(aa, p)
	case *UpdateExpression:
		aa, ok := a.(*UpdateExpression)
		if !ok {
			return false
		}
		return matchUpdateExpression(aa, p)
	case *VariableDeclarator:
		aa, ok := a.(*VariableDeclarator)
		if !ok {
			return false
		}
		return matchVariableDeclarator(aa, p)
	case *YieldExpression:
		aa, ok := a.(*YieldExpression)
		if !ok {
			return false
		}
		return matchYieldExpression(aa, p)
	default:
		return false
	}
}

func matchForLoopInit(a, p ForLoopInit) bool {
	if p == nil {
		return true
	}
	if a == nil {
		return false
	}
	switch p := p.(type) {
	case *Expression:
		aa, ok := a.(*Expression)
		if !ok {
			return false
		}
		return matchExpression(aa, p)
	case *VariableDeclaration:
		aa, ok := a.(*VariableDeclaration)
		if !ok {
			return false
		}
		return matchVariableDeclaration(aa, p)
	default:
		return false
	}
}

func matchInto(a, p Into) bool {
	if p == nil {
		return true
	}
	if a == nil {
		return false
	}
	switch p := p.(type) {
	case *Expression:
		aa, ok := a.(*Expression)
		if !ok {
			return false
		}
		return matchExpression(aa, p)
	case *VariableDeclaration:
		aa, ok := a.(*VariableDeclaration)
		if !ok {
			return false
		}
		return matchVariableDeclaration(aa, p)
	default:
		return false
	}
}

func matchMemberProp(a, p MemberProp) bool {
	if p == nil {
		return true
	}
	if a == nil {
		return false
	}
	switch p := p.(type) {
	case *ComputedProperty:
		aa, ok := a.(*ComputedProperty)
		if !ok {
			return false
		}
		return matchComputedProperty(aa, p)
	case *Identifier:
		aa, ok := a.(*Identifier)
		if !ok {
			return false
		}
		return matchIdentifier(aa, p)
	default:
		return false
	}
}

func matchPattern(a, p Pattern) bool {
	if p == nil {
		return true
	}
	if a == nil {
		return false
	}
	switch p := p.(type) {
	case *ArrayPattern:
		aa, ok := a.(*ArrayPattern)
		if !ok {
			return false
		}
		return matchArrayPattern(aa, p)
	case *ObjectPattern:
		aa, ok := a.(*ObjectPattern)
		if !ok {
			return false
		}
		return matchObjectPattern(aa, p)
	default:
		return false
	}
}

func matchProp(a, p Prop) bool {
	if p == nil {
		return true
	}
	if a == nil {
		return false
	}
	switch p := p.(type) {
	case *PropertyKeyed:
		aa, ok := a.(*PropertyKeyed)
		if !ok {
			return false
		}
		return matchPropertyKeyed(aa, p)
	case *PropertyShort:
		aa, ok := a.(*PropertyShort)
		if !ok {
			return false
		}
		return matchPropertyShort(aa, p)
	case *SpreadElement:
		aa, ok := a.(*SpreadElement)
		if !ok {
			return false
		}
		return matchSpreadElement(aa, p)
	default:
		return false
	}
}

func matchStmt(a, p Stmt) bool {
	if p == nil {
		return true
	}
	if a == nil {
		return false
	}
	switch p := p.(type) {
	case *Any:
		return true
	case *Capture:
		return bindCapture(a, p.Out)
	case *BadStatement:
		aa, ok := a.(*BadStatement)
		if !ok {
			return false
		}
		return matchBadStatement(aa, p)
	case *BlockStatement:
		aa, ok := a.(*BlockStatement)
		if !ok {
			return false
		}
		return matchBlockStatement(aa, p)
	case *BreakStatement:
		aa, ok := a.(*BreakStatement)
		if !ok {
			return false
		}
		return matchBreakStatement(aa, p)
	case *CaseStatement:
		aa, ok := a.(*CaseStatement)
		if !ok {
			return false
		}
		return matchCaseStatement(aa, p)
	case *CatchStatement:
		aa, ok := a.(*CatchStatement)
		if !ok {
			return false
		}
		return matchCatchStatement(aa, p)
	case *ClassDeclaration:
		aa, ok := a.(*ClassDeclaration)
		if !ok {
			return false
		}
		return matchClassDeclaration(aa, p)
	case *ContinueStatement:
		aa, ok := a.(*ContinueStatement)
		if !ok {
			return false
		}
		return matchContinueStatement(aa, p)
	case *DebuggerStatement:
		aa, ok := a.(*DebuggerStatement)
		if !ok {
			return false
		}
		return matchDebuggerStatement(aa, p)
	case *DoWhileStatement:
		aa, ok := a.(*DoWhileStatement)
		if !ok {
			return false
		}
		return matchDoWhileStatement(aa, p)
	case *EmptyStatement:
		aa, ok := a.(*EmptyStatement)
		if !ok {
			return false
		}
		return matchEmptyStatement(aa, p)
	case *ExpressionStatement:
		aa, ok := a.(*ExpressionStatement)
		if !ok {
			return false
		}
		return matchExpressionStatement(aa, p)
	case *ForInStatement:
		aa, ok := a.(*ForInStatement)
		if !ok {
			return false
		}
		return matchForInStatement(aa, p)
	case *ForOfStatement:
		aa, ok := a.(*ForOfStatement)
		if !ok {
			return false
		}
		return matchForOfStatement(aa, p)
	case *ForStatement:
		aa, ok := a.(*ForStatement)
		if !ok {
			return false
		}
		return matchForStatement(aa, p)
	case *FunctionDeclaration:
		aa, ok := a.(*FunctionDeclaration)
		if !ok {
			return false
		}
		return matchFunctionDeclaration(aa, p)
	case *IfStatement:
		aa, ok := a.(*IfStatement)
		if !ok {
			return false
		}
		return matchIfStatement(aa, p)
	case *LabelledStatement:
		aa, ok := a.(*LabelledStatement)
		if !ok {
			return false
		}
		return matchLabelledStatement(aa, p)
	case *ReturnStatement:
		aa, ok := a.(*ReturnStatement)
		if !ok {
			return false
		}
		return matchReturnStatement(aa, p)
	case *SwitchStatement:
		aa, ok := a.(*SwitchStatement)
		if !ok {
			return false
		}
		return matchSwitchStatement(aa, p)
	case *ThrowStatement:
		aa, ok := a.(*ThrowStatement)
		if !ok {
			return false
		}
		return matchThrowStatement(aa, p)
	case *TryStatement:
		aa, ok := a.(*TryStatement)
		if !ok {
			return false
		}
		return matchTryStatement(aa, p)
	case *VariableDeclaration:
		aa, ok := a.(*VariableDeclaration)
		if !ok {
			return false
		}
		return matchVariableDeclaration(aa, p)
	case *WhileStatement:
		aa, ok := a.(*WhileStatement)
		if !ok {
			return false
		}
		return matchWhileStatement(aa, p)
	case *WithStatement:
		aa, ok := a.(*WithStatement)
		if !ok {
			return false
		}
		return matchWithStatement(aa, p)
	default:
		return false
	}
}

func matchTarget(a, p Target) bool {
	if p == nil {
		return true
	}
	if a == nil {
		return false
	}
	switch p := p.(type) {
	case *ArrayPattern:
		aa, ok := a.(*ArrayPattern)
		if !ok {
			return false
		}
		return matchArrayPattern(aa, p)
	case *Identifier:
		aa, ok := a.(*Identifier)
		if !ok {
			return false
		}
		return matchIdentifier(aa, p)
	case *InvalidExpression:
		aa, ok := a.(*InvalidExpression)
		if !ok {
			return false
		}
		return matchInvalidExpression(aa, p)
	case *MemberExpression:
		aa, ok := a.(*MemberExpression)
		if !ok {
			return false
		}
		return matchMemberExpression(aa, p)
	case *ObjectPattern:
		aa, ok := a.(*ObjectPattern)
		if !ok {
			return false
		}
		return matchObjectPattern(aa, p)
	default:
		return false
	}
}

func matchCaseStatements(a, p CaseStatements) bool {
	if len(a) != len(p) {
		return false
	}
	for i := 0; i < len(p); i++ {
		if !(matchCaseStatement(&a[i], &p[i])) {
			return false
		}
	}
	return true
}

func matchClassElements(a, p ClassElements) bool {
	if len(a) != len(p) {
		return false
	}
	for i := 0; i < len(p); i++ {
		if !(matchClassElement(&a[i], &p[i])) {
			return false
		}
	}
	return true
}

func matchExpressions(a, p Expressions) bool {
	if len(a) != len(p) {
		return false
	}
	for i := 0; i < len(p); i++ {
		if !(matchExpression(&a[i], &p[i])) {
			return false
		}
	}
	return true
}

func matchProperties(a, p Properties) bool {
	if len(a) != len(p) {
		return false
	}
	for i := 0; i < len(p); i++ {
		if !(matchProperty(&a[i], &p[i])) {
			return false
		}
	}
	return true
}

func matchStatements(a, p Statements) bool {
	if len(a) != len(p) {
		return false
	}
	for i := 0; i < len(p); i++ {
		if !(matchStatement(&a[i], &p[i])) {
			return false
		}
	}
	return true
}

func matchTemplateElements(a, p TemplateElements) bool {
	if len(a) != len(p) {
		return false
	}
	for i := 0; i < len(p); i++ {
		if !(matchTemplateElement(&a[i], &p[i])) {
			return false
		}
	}
	return true
}

func matchVariableDeclarators(a, p VariableDeclarators) bool {
	if len(a) != len(p) {
		return false
	}
	for i := 0; i < len(p); i++ {
		if !(matchVariableDeclarator(&a[i], &p[i])) {
			return false
		}
	}
	return true
}

func matchArrayLiteral(a, p *ArrayLiteral) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpressions(a.Value, p.Value)) {
		return false
	}
	return true
}

func matchArrayPattern(a, p *ArrayPattern) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpressions(a.Elements, p.Elements)) {
		return false
	}
	if !(matchExpression(a.Rest, p.Rest)) {
		return false
	}
	return true
}

func matchArrowFunctionLiteral(a, p *ArrowFunctionLiteral) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchParameterList(&a.ParameterList, &p.ParameterList)) {
		return false
	}
	if !(matchConciseBody(a.Body, p.Body)) {
		return false
	}
	if !(a.Async == p.Async) {
		return false
	}
	return true
}

func matchAssignExpression(a, p *AssignExpression) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Operator == p.Operator) {
		return false
	}
	if !(matchExpression(a.Left, p.Left)) {
		return false
	}
	if !(matchExpression(a.Right, p.Right)) {
		return false
	}
	return true
}

func matchAwaitExpression(a, p *AwaitExpression) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Argument, p.Argument)) {
		return false
	}
	return true
}

func matchBadStatement(a, p *BadStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	return true
}

func matchBinaryExpression(a, p *BinaryExpression) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Operator == p.Operator) {
		return false
	}
	if !(matchExpression(a.Left, p.Left)) {
		return false
	}
	if !(matchExpression(a.Right, p.Right)) {
		return false
	}
	return true
}

func matchBindingTarget(a, p *BindingTarget) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchTarget(a.Target, p.Target)) {
		return false
	}
	return true
}

func matchBlockStatement(a, p *BlockStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchStatements(a.List, p.List)) {
		return false
	}
	return true
}

func matchBooleanLiteral(a, p *BooleanLiteral) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Value == p.Value) {
		return false
	}
	return true
}

func matchBreakStatement(a, p *BreakStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchIdentifier(a.Label, p.Label)) {
		return false
	}
	return true
}

func matchCallExpression(a, p *CallExpression) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Callee, p.Callee)) {
		return false
	}
	if !(matchExpressions(a.ArgumentList, p.ArgumentList)) {
		return false
	}
	return true
}

func matchCaseStatement(a, p *CaseStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Test, p.Test)) {
		return false
	}
	if !(matchStatements(a.Consequent, p.Consequent)) {
		return false
	}
	return true
}

func matchCatchStatement(a, p *CatchStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchBindingTarget(a.Parameter, p.Parameter)) {
		return false
	}
	if !(matchBlockStatement(a.Body, p.Body)) {
		return false
	}
	return true
}

func matchClassDeclaration(a, p *ClassDeclaration) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchClassLiteral(a.Class, p.Class)) {
		return false
	}
	return true
}

func matchClassElement(a, p *ClassElement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchElement(a.Element, p.Element)) {
		return false
	}
	return true
}

func matchClassLiteral(a, p *ClassLiteral) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchIdentifier(a.Name, p.Name)) {
		return false
	}
	if !(matchExpression(a.SuperClass, p.SuperClass)) {
		return false
	}
	if !(matchClassElements(a.Body, p.Body)) {
		return false
	}
	return true
}

func matchClassStaticBlock(a, p *ClassStaticBlock) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchBlockStatement(a.Block, p.Block)) {
		return false
	}
	return true
}

func matchComputedProperty(a, p *ComputedProperty) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Expr, p.Expr)) {
		return false
	}
	return true
}

func matchConciseBody(a, p *ConciseBody) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchBody(a.Body, p.Body)) {
		return false
	}
	return true
}

func matchConditionalExpression(a, p *ConditionalExpression) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Test, p.Test)) {
		return false
	}
	if !(matchExpression(a.Consequent, p.Consequent)) {
		return false
	}
	if !(matchExpression(a.Alternate, p.Alternate)) {
		return false
	}
	return true
}

func matchContinueStatement(a, p *ContinueStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchIdentifier(a.Label, p.Label)) {
		return false
	}
	return true
}

func matchDebuggerStatement(a, p *DebuggerStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	return true
}

func matchDoWhileStatement(a, p *DoWhileStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Test, p.Test)) {
		return false
	}
	if !(matchStatement(a.Body, p.Body)) {
		return false
	}
	return true
}

func matchEmptyStatement(a, p *EmptyStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	return true
}

func matchExpression(a, p *Expression) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpr(a.Expr, p.Expr)) {
		return false
	}
	return true
}

func matchExpressionStatement(a, p *ExpressionStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Expression, p.Expression)) {
		return false
	}
	if !(a.Comment == p.Comment) {
		return false
	}
	return true
}

func matchFieldDefinition(a, p *FieldDefinition) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Key, p.Key)) {
		return false
	}
	if !(matchExpression(a.Initializer, p.Initializer)) {
		return false
	}
	if !(a.Computed == p.Computed) {
		return false
	}
	if !(a.Static == p.Static) {
		return false
	}
	return true
}

func matchForInStatement(a, p *ForInStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchForInto(a.Into, p.Into)) {
		return false
	}
	if !(matchExpression(a.Source, p.Source)) {
		return false
	}
	if !(matchStatement(a.Body, p.Body)) {
		return false
	}
	return true
}

func matchForInto(a, p *ForInto) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchInto(a.Into, p.Into)) {
		return false
	}
	return true
}

func matchForLoopInitializer(a, p *ForLoopInitializer) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchForLoopInit(a.Initializer, p.Initializer)) {
		return false
	}
	return true
}

func matchForOfStatement(a, p *ForOfStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchForInto(a.Into, p.Into)) {
		return false
	}
	if !(matchExpression(a.Source, p.Source)) {
		return false
	}
	if !(matchStatement(a.Body, p.Body)) {
		return false
	}
	return true
}

func matchForStatement(a, p *ForStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchForLoopInitializer(a.Initializer, p.Initializer)) {
		return false
	}
	if !(matchExpression(a.Update, p.Update)) {
		return false
	}
	if !(matchExpression(a.Test, p.Test)) {
		return false
	}
	if !(matchStatement(a.Body, p.Body)) {
		return false
	}
	return true
}

func matchFunctionDeclaration(a, p *FunctionDeclaration) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchFunctionLiteral(a.Function, p.Function)) {
		return false
	}
	return true
}

func matchFunctionLiteral(a, p *FunctionLiteral) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchIdentifier(a.Name, p.Name)) {
		return false
	}
	if !(matchParameterList(&a.ParameterList, &p.ParameterList)) {
		return false
	}
	if !(matchBlockStatement(a.Body, p.Body)) {
		return false
	}
	if !(a.Async == p.Async) {
		return false
	}
	if !(a.Generator == p.Generator) {
		return false
	}
	return true
}

func matchIdentifier(a, p *Identifier) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Name == p.Name) {
		return false
	}
	return true
}

func matchIfStatement(a, p *IfStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Test, p.Test)) {
		return false
	}
	if !(matchStatement(a.Consequent, p.Consequent)) {
		return false
	}
	if !(matchStatement(a.Alternate, p.Alternate)) {
		return false
	}
	return true
}

func matchInvalidExpression(a, p *InvalidExpression) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	return true
}

func matchLabelledStatement(a, p *LabelledStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchIdentifier(a.Label, p.Label)) {
		return false
	}
	if !(matchStatement(a.Statement, p.Statement)) {
		return false
	}
	return true
}

func matchMemberExpression(a, p *MemberExpression) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Object, p.Object)) {
		return false
	}
	if !(matchMemberProperty(a.Property, p.Property)) {
		return false
	}
	return true
}

func matchMemberProperty(a, p *MemberProperty) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchMemberProp(a.Prop, p.Prop)) {
		return false
	}
	return true
}

func matchMetaProperty(a, p *MetaProperty) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchIdentifier(a.Meta, p.Meta)) {
		return false
	}
	if !(matchIdentifier(a.Property, p.Property)) {
		return false
	}
	return true
}

func matchMethodDefinition(a, p *MethodDefinition) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Key, p.Key)) {
		return false
	}
	if !(a.Kind == p.Kind) {
		return false
	}
	if !(matchFunctionLiteral(a.Body, p.Body)) {
		return false
	}
	if !(a.Computed == p.Computed) {
		return false
	}
	if !(a.Static == p.Static) {
		return false
	}
	return true
}

func matchNewExpression(a, p *NewExpression) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Callee, p.Callee)) {
		return false
	}
	if !(matchExpressions(a.ArgumentList, p.ArgumentList)) {
		return false
	}
	return true
}

func matchNullLiteral(a, p *NullLiteral) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	return true
}

func matchNumberLiteral(a, p *NumberLiteral) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Value == p.Value) {
		return false
	}
	if !((p.Raw == nil && a.Raw == nil) || (p.Raw != nil && a.Raw != nil && *a.Raw == *p.Raw)) {
		return false
	}
	return true
}

func matchObjectLiteral(a, p *ObjectLiteral) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchProperties(a.Value, p.Value)) {
		return false
	}
	return true
}

func matchObjectPattern(a, p *ObjectPattern) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchProperties(a.Properties, p.Properties)) {
		return false
	}
	if !(matchExpr(a.Rest, p.Rest)) {
		return false
	}
	return true
}

func matchOptional(a, p *Optional) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Expr, p.Expr)) {
		return false
	}
	return true
}

func matchOptionalChain(a, p *OptionalChain) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Base, p.Base)) {
		return false
	}
	return true
}

func matchParameterList(a, p *ParameterList) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchVariableDeclarators(a.List, p.List)) {
		return false
	}
	if !(matchExpr(a.Rest, p.Rest)) {
		return false
	}
	return true
}

func matchPrivateDotExpression(a, p *PrivateDotExpression) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Left, p.Left)) {
		return false
	}
	if !(matchPrivateIdentifier(a.Identifier, p.Identifier)) {
		return false
	}
	return true
}

func matchPrivateIdentifier(a, p *PrivateIdentifier) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchIdentifier(a.Identifier, p.Identifier)) {
		return false
	}
	return true
}

func matchProgram(a, p *Program) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchStatements(a.Body, p.Body)) {
		return false
	}
	return true
}

func matchProperty(a, p *Property) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchProp(a.Prop, p.Prop)) {
		return false
	}
	return true
}

func matchPropertyKeyed(a, p *PropertyKeyed) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Key, p.Key)) {
		return false
	}
	if !(a.Kind == p.Kind) {
		return false
	}
	if !(matchExpression(a.Value, p.Value)) {
		return false
	}
	if !(a.Computed == p.Computed) {
		return false
	}
	return true
}

func matchPropertyShort(a, p *PropertyShort) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchIdentifier(a.Name, p.Name)) {
		return false
	}
	if !(matchExpression(a.Initializer, p.Initializer)) {
		return false
	}
	return true
}

func matchRegExpLiteral(a, p *RegExpLiteral) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Literal == p.Literal) {
		return false
	}
	if !(a.Pattern == p.Pattern) {
		return false
	}
	if !(a.Flags == p.Flags) {
		return false
	}
	return true
}

func matchReturnStatement(a, p *ReturnStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Argument, p.Argument)) {
		return false
	}
	return true
}

func matchSequenceExpression(a, p *SequenceExpression) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpressions(a.Sequence, p.Sequence)) {
		return false
	}
	return true
}

func matchSpreadElement(a, p *SpreadElement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Expression, p.Expression)) {
		return false
	}
	return true
}

func matchStatement(a, p *Statement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchStmt(a.Stmt, p.Stmt)) {
		return false
	}
	return true
}

func matchStringLiteral(a, p *StringLiteral) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Value == p.Value) {
		return false
	}
	if !((p.Raw == nil && a.Raw == nil) || (p.Raw != nil && a.Raw != nil && *a.Raw == *p.Raw)) {
		return false
	}
	return true
}

func matchSuperExpression(a, p *SuperExpression) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	return true
}

func matchSwitchStatement(a, p *SwitchStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Discriminant, p.Discriminant)) {
		return false
	}
	if !(a.Default == p.Default) {
		return false
	}
	if !(matchCaseStatements(a.Body, p.Body)) {
		return false
	}
	return true
}

func matchTemplateElement(a, p *TemplateElement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Literal == p.Literal) {
		return false
	}
	if !(a.Parsed == p.Parsed) {
		return false
	}
	if !(a.Valid == p.Valid) {
		return false
	}
	return true
}

func matchTemplateLiteral(a, p *TemplateLiteral) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Tag, p.Tag)) {
		return false
	}
	if !(matchTemplateElements(a.Elements, p.Elements)) {
		return false
	}
	if !(matchExpressions(a.Expressions, p.Expressions)) {
		return false
	}
	return true
}

func matchThisExpression(a, p *ThisExpression) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	return true
}

func matchThrowStatement(a, p *ThrowStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Argument, p.Argument)) {
		return false
	}
	return true
}

func matchTryStatement(a, p *TryStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchBlockStatement(a.Body, p.Body)) {
		return false
	}
	if !(matchCatchStatement(a.Catch, p.Catch)) {
		return false
	}
	if !(matchBlockStatement(a.Finally, p.Finally)) {
		return false
	}
	return true
}

func matchUnaryExpression(a, p *UnaryExpression) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Operator == p.Operator) {
		return false
	}
	if !(matchExpression(a.Operand, p.Operand)) {
		return false
	}
	return true
}

func matchUpdateExpression(a, p *UpdateExpression) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Operator == p.Operator) {
		return false
	}
	if !(matchExpression(a.Operand, p.Operand)) {
		return false
	}
	if !(a.Postfix == p.Postfix) {
		return false
	}
	return true
}

func matchVariableDeclaration(a, p *VariableDeclaration) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Token == p.Token) {
		return false
	}
	if !(matchVariableDeclarators(a.List, p.List)) {
		return false
	}
	if !(a.Comment == p.Comment) {
		return false
	}
	return true
}

func matchVariableDeclarator(a, p *VariableDeclarator) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchBindingTarget(a.Target, p.Target)) {
		return false
	}
	if !(matchExpression(a.Initializer, p.Initializer)) {
		return false
	}
	return true
}

func matchWhileStatement(a, p *WhileStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Test, p.Test)) {
		return false
	}
	if !(matchStatement(a.Body, p.Body)) {
		return false
	}
	return true
}

func matchWithStatement(a, p *WithStatement) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Object, p.Object)) {
		return false
	}
	if !(matchStatement(a.Body, p.Body)) {
		return false
	}
	return true
}

func matchYieldExpression(a, p *YieldExpression) bool {
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpression(a.Argument, p.Argument)) {
		return false
	}
	if !(a.Delegate == p.Delegate) {
		return false
	}
	return true
}
