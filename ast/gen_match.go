//go:build ignore

package main

import (
	"bytes"
	"cmp"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"log"
	"os"
	"slices"
	"strings"
)

// Generates match_gen.go (type-safe AST matching).

type Field struct {
	Name string
	Type ast.Expr
}

type StructType struct {
	Name   string
	Fields []Field
}

type SliceType struct {
	Name string
	Elem ast.Expr
}

type MatchInterface struct {
	Name       string
	UniqueFunc string
	Structs    []string
}

func main() {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, ".", func(info fs.FileInfo) bool {
		switch info.Name() {
		case "visit.go", "clone.go", "match_gen.go", "match.go":
			return false
		default:
			return true
		}
	}, parser.ParseComments)
	if err != nil {
		log.Fatalf("%v", err)
	}

	files := pkgs["ast"].Files

	structs, slicesByName := findTypes(files)
	interfaces := findMatchInterfaces(files)
	for _, f := range files {
		findStructsForInterfaces(f, interfaces)
	}

	slices.SortFunc(structs, func(a, b StructType) int { return cmp.Compare(a.Name, b.Name) })
	slices.SortFunc(interfaces, func(a, b MatchInterface) int { return cmp.Compare(a.Name, b.Name) })
	for i := range interfaces {
		slices.SortFunc(interfaces[i].Structs, func(a, b string) int { return cmp.Compare(a, b) })
	}

	structSet := make(map[string]struct{}, len(structs))
	for _, st := range structs {
		structSet[st.Name] = struct{}{}
	}
	sliceSet := make(map[string]SliceType, len(slicesByName))
	for k, v := range slicesByName {
		sliceSet[k] = v
	}

	interfaceSet := make(map[string]MatchInterface, len(interfaces))
	for _, it := range interfaces {
		interfaceSet[it.Name] = it
	}

	var out bytes.Buffer
	out.WriteString("// Code generated by gen_match.go; DO NOT EDIT.\n")
	out.WriteString("package ast\n\n")

	// Entry point used by ast.Match().
	out.WriteString("func matchAny(actual any, pattern any) bool {\n")
	out.WriteString("\tif pattern == nil {\n\t\treturn true\n\t}\n")
	out.WriteString("\tswitch p := pattern.(type) {\n")
	out.WriteString("\tcase *Any:\n\t\treturn true\n")
	out.WriteString("\tcase *Capture:\n\t\treturn bindCapture(actual, p.Out)\n")

	// Prefer concrete struct pointers/values first for wrappers like *Expression, *Statement, etc.
	for _, st := range structs {
		out.WriteString("\tcase *" + st.Name + ":\n")
		out.WriteString("\t\ta, ok := actual.(*" + st.Name + ")\n")
		out.WriteString("\t\tif !ok {\n\t\t\treturn false\n\t\t}\n")
		out.WriteString("\t\treturn match" + st.Name + "(a, p)\n")
		out.WriteString("\tcase " + st.Name + ":\n")
		out.WriteString("\t\ta, ok := actual.(" + st.Name + ")\n")
		out.WriteString("\t\tif !ok {\n\t\t\treturn false\n\t\t}\n")
		out.WriteString("\t\treturn match" + st.Name + "(&a, &p)\n")
	}

	// Slice aliases.
	var sliceNames []string
	for name := range sliceSet {
		sliceNames = append(sliceNames, name)
	}
	slices.Sort(sliceNames)
	for _, name := range sliceNames {
		out.WriteString("\tcase " + name + ":\n")
		out.WriteString("\t\ta, ok := actual.(" + name + ")\n")
		out.WriteString("\t\tif !ok {\n\t\t\treturn false\n\t\t}\n")
		out.WriteString("\t\treturn match" + name + "(a, p)\n")
	}

	// Marker interfaces (Expr, Stmt, etc).
	for _, it := range interfaces {
		out.WriteString("\tcase " + it.Name + ":\n")
		out.WriteString("\t\ta, ok := actual.(" + it.Name + ")\n")
		out.WriteString("\t\tif !ok {\n\t\t\treturn false\n\t\t}\n")
		out.WriteString("\t\treturn match" + it.Name + "(a, p)\n")
	}

	out.WriteString("\tdefault:\n\t\treturn false\n\t}\n}\n\n")

	// Capture binder (no reflection): supports **T where T is any struct type pointer in ast.
	out.WriteString("func bindCapture(actual any, out any) bool {\n")
	out.WriteString("\tswitch dst := out.(type) {\n")
	for _, st := range structs {
		out.WriteString("\tcase **" + st.Name + ":\n")
		out.WriteString("\t\tv, ok := actual.(*" + st.Name + ")\n")
		out.WriteString("\t\tif !ok {\n\t\t\treturn false\n\t\t}\n")
		out.WriteString("\t\t*dst = v\n\t\treturn true\n")
	}
	out.WriteString("\tdefault:\n\t\treturn false\n\t}\n}\n\n")

	// Interface matchers.
	for _, it := range interfaces {
		out.WriteString("func match" + it.Name + "(a, p " + it.Name + ") bool {\n")
		out.WriteString("\tif p == nil {\n\t\treturn true\n\t}\n")
		out.WriteString("\tif a == nil {\n\t\treturn false\n\t}\n")
		out.WriteString("\tswitch p := p.(type) {\n")

		// Special pattern nodes: only for Expr/Stmt.
		if it.Name == "Expr" || it.Name == "Stmt" {
			out.WriteString("\tcase *Any:\n\t\treturn true\n")
			out.WriteString("\tcase *Capture:\n\t\treturn bindCapture(a, p.Out)\n")
		}

		for _, s := range it.Structs {
			out.WriteString("\tcase *" + s + ":\n")
			out.WriteString("\t\taa, ok := a.(*" + s + ")\n")
			out.WriteString("\t\tif !ok {\n\t\t\treturn false\n\t\t}\n")
			out.WriteString("\t\treturn match" + s + "(aa, p)\n")
		}
		out.WriteString("\tdefault:\n\t\treturn false\n\t}\n}\n\n")
	}

	// Slice matchers.
	for _, name := range sliceNames {
		sl := sliceSet[name]
		out.WriteString("func match" + name + "(a, p " + name + ") bool {\n")
		out.WriteString("\tif len(a) != len(p) {\n\t\treturn false\n\t}\n")
		out.WriteString("\tfor i := 0; i < len(p); i++ {\n")
		out.WriteString("\t\tif !(" + matchExprFor("a[i]", "p[i]", sl.Elem, structSet, interfaceSet, sliceSet) + ") {\n")
		out.WriteString("\t\t\treturn false\n\t\t}\n")
		out.WriteString("\t}\n\treturn true\n}\n\n")
	}

	// Struct matchers.
	for _, st := range structs {
		out.WriteString("func match" + st.Name + "(a, p *" + st.Name + ") bool {\n")
		out.WriteString("\tif p == nil {\n\t\treturn a == nil\n\t}\n")
		out.WriteString("\tif a == nil {\n\t\treturn false\n\t}\n")
		for _, f := range st.Fields {
			// Skip source positions and scope contexts, like the old reflect matcher.
			if ident, ok := f.Type.(*ast.Ident); ok {
				if ident.Name == "Idx" || ident.Name == "ScopeContext" {
					continue
				}
			}
			out.WriteString("\tif !(" + matchExprFor("a."+f.Name, "p."+f.Name, f.Type, structSet, interfaceSet, sliceSet) + ") {\n")
			out.WriteString("\t\treturn false\n\t}\n")
		}
		out.WriteString("\treturn true\n}\n\n")
	}

	formatted, err := format.Source(out.Bytes())
	if err != nil {
		log.Fatalf("format: %v\n%s", err, out.String())
	}
	if err := os.WriteFile("match_gen.go", formatted, 0644); err != nil {
		log.Fatalf("write: %v", err)
	}
}

func findTypes(files map[string]*ast.File) ([]StructType, map[string]SliceType) {
	var structs []StructType
	slicesByName := map[string]SliceType{}

	for _, f := range files {
		for _, decl := range f.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok || gen.Tok != token.TYPE {
				continue
			}
			for _, spec := range gen.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				switch ts.Name.Name {
				case "ScopeContext", "Id", "Idx":
					continue
				}
				switch t := ts.Type.(type) {
				case *ast.StructType:
					structs = append(structs, StructType{
						Name:   ts.Name.Name,
						Fields: findExportedFields(t.Fields.List),
					})
				case *ast.ArrayType:
					// Only slices (Len == nil).
					if t.Len == nil {
						slicesByName[ts.Name.Name] = SliceType{Name: ts.Name.Name, Elem: t.Elt}
					}
				}
			}
		}
	}
	return structs, slicesByName
}

func findExportedFields(fields []*ast.Field) (out []Field) {
	for _, f := range fields {
		// Anonymous field: Names == nil, use the identifier name.
		if len(f.Names) == 0 {
			switch t := f.Type.(type) {
			case *ast.Ident:
				if ast.IsExported(t.Name) {
					out = append(out, Field{Name: t.Name, Type: f.Type})
				}
			default:
				// Ignore other embedded forms.
			}
			continue
		}
		for _, name := range f.Names {
			if name == nil || !ast.IsExported(name.Name) {
				continue
			}
			out = append(out, Field{Name: name.Name, Type: f.Type})
		}
	}
	return out
}

func findMatchInterfaces(files map[string]*ast.File) []MatchInterface {
	var interfaces []MatchInterface
	for _, f := range files {
		for _, decl := range f.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok || gen.Tok != token.TYPE {
				continue
			}
			for _, spec := range gen.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				switch ts.Name.Name {
				case "Node", "VisitableNode", "CloneableNode":
					continue
				}
				it, ok := ts.Type.(*ast.InterfaceType)
				if !ok {
					continue
				}
				idx := slices.IndexFunc(it.Methods.List, func(a *ast.Field) bool {
					if len(a.Names) == 0 {
						return false
					}
					return strings.HasPrefix(a.Names[0].Name, "_")
				})
				if idx == -1 {
					continue
				}
				interfaces = append(interfaces, MatchInterface{
					Name:       ts.Name.Name,
					UniqueFunc: it.Methods.List[idx].Names[0].Name,
				})
			}
		}
	}
	return interfaces
}

func findStructsForInterfaces(f *ast.File, interfaces []MatchInterface) {
	for _, decl := range f.Decls {
		fn, ok := decl.(*ast.FuncDecl)
		if !ok || fn.Recv == nil || len(fn.Recv.List) == 0 {
			continue
		}
		recvStar, ok := fn.Recv.List[0].Type.(*ast.StarExpr)
		if !ok {
			continue
		}
		recvIdent, ok := recvStar.X.(*ast.Ident)
		if !ok {
			continue
		}
		idx := slices.IndexFunc(interfaces, func(i MatchInterface) bool { return i.UniqueFunc == fn.Name.Name })
		if idx == -1 {
			continue
		}
		interfaces[idx].Structs = append(interfaces[idx].Structs, recvIdent.Name)
	}
}

func matchExprFor(aExpr, pExpr string, t ast.Expr, structSet map[string]struct{}, interfaceSet map[string]MatchInterface, sliceSet map[string]SliceType) string {
	switch tt := t.(type) {
	case *ast.Ident:
		// Interfaces
		if _, ok := interfaceSet[tt.Name]; ok {
			return "match" + tt.Name + "(" + aExpr + ", " + pExpr + ")"
		}
		// Slice aliases
		if _, ok := sliceSet[tt.Name]; ok {
			return "match" + tt.Name + "(" + aExpr + ", " + pExpr + ")"
		}
		// Structs by value
		if _, ok := structSet[tt.Name]; ok {
			return "match" + tt.Name + "(&" + aExpr + ", &" + pExpr + ")"
		}
		// Scalars
		return aExpr + " == " + pExpr
	case *ast.StarExpr:
		// Pointer: nil-sensitive.
		if ident, ok := tt.X.(*ast.Ident); ok {
			// Pointer to struct.
			if _, ok := structSet[ident.Name]; ok {
				return "match" + ident.Name + "(" + aExpr + ", " + pExpr + ")"
			}
			// Pointer to scalar.
			return "((" + pExpr + " == nil && " + aExpr + " == nil) || (" + pExpr + " != nil && " + aExpr + " != nil && *" + aExpr + " == *" + pExpr + "))"
		}
		// Fallback.
		return aExpr + " == " + pExpr
	case *ast.SelectorExpr:
		// token.Token, etc. Comparable.
		return aExpr + " == " + pExpr
	default:
		// Unknown field types are not expected in this AST.
		return aExpr + " == " + pExpr
	}
}

