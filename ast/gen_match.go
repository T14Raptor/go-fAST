//go:build ignore

package main

import (
	"bytes"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"log"
	"os"
	"slices"
	"strings"
)

type Field struct {
	Name string
	Type ast.Expr
}

type StructType struct {
	Name   string
	Fields []Field
}

type SliceType struct {
	Name string
	Elem ast.Expr
}

// Generates match.go (type-safe AST matching).

func main() {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, ".", func(info fs.FileInfo) bool {
		switch info.Name() {
		case "visit.go", "clone.go", "match.go", "match_gen.go":
			return false
		default:
			return true
		}
	}, parser.ParseComments)
	if err != nil {
		log.Fatalf("%v", err)
	}

	files := pkgs["ast"].Files

	structs, slicesByName, interfacesByName := findTypes(files)
	slices.SortFunc(structs, func(a, b StructType) int { return strings.Compare(a.Name, b.Name) })

	structSet := make(map[string]struct{}, len(structs))
	for _, st := range structs {
		structSet[st.Name] = struct{}{}
	}
	sliceSet := slicesByName

	var out bytes.Buffer
	out.WriteString("// Code generated by gen_match.go; DO NOT EDIT.\n")
	out.WriteString("package ast\n\n")

	// Core API
	out.WriteString("type Matcher interface {\n\tmatch(actual any) bool\n}\n\n")

	out.WriteString("func Match(actual, pattern any) bool {\n")
	out.WriteString("\tif pattern == nil {\n\t\treturn true\n\t}\n")
	out.WriteString("\tm, ok := pattern.(Matcher)\n")
	out.WriteString("\tif !ok {\n\t\treturn false\n\t}\n")
	out.WriteString("\treturn m.match(actual)\n")
	out.WriteString("}\n\n")

	// Pattern nodes
	out.WriteString("type Any struct{}\n\n")
	out.WriteString("func AnyNode() *Any { return &Any{} }\n\n")
	out.WriteString("type Capture struct{ Out any }\n\n")
	out.WriteString("func CaptureNode(out any) *Capture { return &Capture{Out: out} }\n\n")

	out.WriteString("func (p *Any) match(actual any) bool { return true }\n\n")
	out.WriteString("func (p *Capture) match(actual any) bool { return bindCapture(actual, p.Out) }\n\n")

	// Capture binder (no reflection, no type-switch): supports **T where T is any AST struct pointer.
	out.WriteString("func bindCapture(actual any, out any) bool {\n")
	out.WriteString("\tif out == nil {\n\t\treturn false\n\t}\n")
	for _, st := range structs {
		out.WriteString("\tif dst, ok := out.(**" + st.Name + "); ok {\n")
		out.WriteString("\t\tv, ok := actual.(*" + st.Name + ")\n")
		out.WriteString("\t\tif !ok {\n\t\t\treturn false\n\t\t}\n")
		out.WriteString("\t\t*dst = v\n\t\treturn true\n\t}\n")
	}
	out.WriteString("\treturn false\n}\n\n")

	// Make Any/Capture usable as Expr/Stmt markers.
	out.WriteString("func (*Any) Idx0() Idx                 { return 0 }\n")
	out.WriteString("func (*Any) Idx1() Idx                 { return 0 }\n")
	out.WriteString("func (*Any) VisitWith(Visitor)         {}\n")
	out.WriteString("func (*Any) VisitChildrenWith(Visitor) {}\n")
	out.WriteString("func (*Any) _expr()                    {}\n")
	out.WriteString("func (*Any) _stmt()                    {}\n\n")

	out.WriteString("func (*Capture) Idx0() Idx                 { return 0 }\n")
	out.WriteString("func (*Capture) Idx1() Idx                 { return 0 }\n")
	out.WriteString("func (*Capture) VisitWith(Visitor)         {}\n")
	out.WriteString("func (*Capture) VisitChildrenWith(Visitor) {}\n")
	out.WriteString("func (*Capture) _expr()                    {}\n")
	out.WriteString("func (*Capture) _stmt()                    {}\n\n")

	// Slice matchers
	var sliceNames []string
	for name := range sliceSet {
		sliceNames = append(sliceNames, name)
	}
	slices.Sort(sliceNames)
	for _, name := range sliceNames {
		sl := sliceSet[name]
		out.WriteString("func match" + name + "(a, p " + name + ") bool {\n")
		out.WriteString("\tif len(a) != len(p) {\n\t\treturn false\n\t}\n")
		out.WriteString("\tfor i := 0; i < len(p); i++ {\n")
		out.WriteString("\t\tif !(" + matchValueExprFor("a[i]", "p[i]", sl.Elem, structSet, sliceSet, interfacesByName) + ") {\n")
		out.WriteString("\t\t\treturn false\n\t\t}\n")
		out.WriteString("\t}\n\treturn true\n}\n\n")
	}

	// Struct matchers (as methods on pattern nodes).
	for _, st := range structs {
		out.WriteString("func (p *" + st.Name + ") match(actual any) bool {\n")
		out.WriteString("\ta, ok := actual.(*" + st.Name + ")\n")
		out.WriteString("\tif !ok {\n\t\treturn false\n\t}\n")
		out.WriteString("\tif p == nil {\n\t\treturn a == nil\n\t}\n")
		out.WriteString("\tif a == nil {\n\t\treturn false\n\t}\n")
		for _, f := range st.Fields {
			// Skip source positions and scope contexts, like the old reflect matcher.
			if ident, ok := f.Type.(*ast.Ident); ok {
				if ident.Name == "Idx" || ident.Name == "ScopeContext" {
					continue
				}
			}
			out.WriteString("\tif !(" + matchFieldExprFor("a."+f.Name, "p."+f.Name, f.Type, structSet, sliceSet, interfacesByName) + ") {\n")
			out.WriteString("\t\treturn false\n\t}\n")
		}
		out.WriteString("\treturn true\n}\n\n")
	}

	formatted, err := format.Source(out.Bytes())
	if err != nil {
		log.Fatalf("format: %v\n%s", err, out.String())
	}
	if err := os.WriteFile("match.go", formatted, 0644); err != nil {
		log.Fatalf("write: %v", err)
	}
}

func findTypes(files map[string]*ast.File) ([]StructType, map[string]SliceType, map[string]struct{}) {
	var structs []StructType
	slicesByName := map[string]SliceType{}
	interfacesByName := map[string]struct{}{}

	for _, f := range files {
		for _, decl := range f.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok || gen.Tok != token.TYPE {
				continue
			}
			for _, spec := range gen.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				switch t := ts.Type.(type) {
				case *ast.InterfaceType:
					interfacesByName[ts.Name.Name] = struct{}{}
				case *ast.StructType:
					structs = append(structs, StructType{
						Name:   ts.Name.Name,
						Fields: findExportedFields(t.Fields.List),
					})
				case *ast.ArrayType:
					// Only slices (Len == nil).
					if t.Len == nil {
						slicesByName[ts.Name.Name] = SliceType{Name: ts.Name.Name, Elem: t.Elt}
					}
				}
			}
		}
	}
	return structs, slicesByName, interfacesByName
}

func findExportedFields(fields []*ast.Field) (out []Field) {
	for _, f := range fields {
		// Anonymous field: Names == nil, use the identifier name.
		if len(f.Names) == 0 {
			switch t := f.Type.(type) {
			case *ast.Ident:
				if ast.IsExported(t.Name) {
					out = append(out, Field{Name: t.Name, Type: f.Type})
				}
			default:
				// Ignore other embedded forms.
			}
			continue
		}
		for _, name := range f.Names {
			if name == nil || !ast.IsExported(name.Name) {
				continue
			}
			out = append(out, Field{Name: name.Name, Type: f.Type})
		}
	}
	return out
}

func matchFieldExprFor(aExpr, pExpr string, t ast.Expr, structSet map[string]struct{}, sliceSet map[string]SliceType, interfaceSet map[string]struct{}) string {
	switch tt := t.(type) {
	case *ast.Ident:
		if _, ok := interfaceSet[tt.Name]; ok {
			// nil pattern interface acts as wildcard (handled by Match).
			return "Match(" + aExpr + ", " + pExpr + ")"
		}
		if _, ok := sliceSet[tt.Name]; ok {
			return "match" + tt.Name + "(" + aExpr + ", " + pExpr + ")"
		}
		if _, ok := structSet[tt.Name]; ok {
			// Compare value structs via their generated matcher methods.
			return "(&" + pExpr + ").match(&" + aExpr + ")"
		}
		return aExpr + " == " + pExpr
	case *ast.SelectorExpr:
		return aExpr + " == " + pExpr
	case *ast.StarExpr:
		if ident, ok := tt.X.(*ast.Ident); ok {
			if _, ok := structSet[ident.Name]; ok {
				return "((" + pExpr + " == nil && " + aExpr + " == nil) || (" + pExpr + " != nil && (" + pExpr + ").match(" + aExpr + ")))"
			}
			// pointer to scalar
			return "((" + pExpr + " == nil && " + aExpr + " == nil) || (" + pExpr + " != nil && " + aExpr + " != nil && *" + aExpr + " == *" + pExpr + "))"
		}
		return aExpr + " == " + pExpr
	default:
		return aExpr + " == " + pExpr
	}
}

func matchValueExprFor(aExpr, pExpr string, t ast.Expr, structSet map[string]struct{}, sliceSet map[string]SliceType, interfaceSet map[string]struct{}) string {
	// Same as matchFieldExprFor but for values like a[i], p[i].
	switch tt := t.(type) {
	case *ast.Ident:
		if _, ok := interfaceSet[tt.Name]; ok {
			return "Match(" + aExpr + ", " + pExpr + ")"
		}
		if _, ok := sliceSet[tt.Name]; ok {
			return "match" + tt.Name + "(" + aExpr + ", " + pExpr + ")"
		}
		if _, ok := structSet[tt.Name]; ok {
			return "(&" + pExpr + ").match(&" + aExpr + ")"
		}
		return aExpr + " == " + pExpr
	case *ast.SelectorExpr:
		return aExpr + " == " + pExpr
	case *ast.StarExpr:
		if ident, ok := tt.X.(*ast.Ident); ok {
			if _, ok := structSet[ident.Name]; ok {
				return "((" + pExpr + " == nil && " + aExpr + " == nil) || (" + pExpr + " != nil && (" + pExpr + ").match(" + aExpr + ")))"
			}
			return "((" + pExpr + " == nil && " + aExpr + " == nil) || (" + pExpr + " != nil && " + aExpr + " != nil && *" + aExpr + " == *" + pExpr + "))"
		}
		return aExpr + " == " + pExpr
	default:
		return aExpr + " == " + pExpr
	}
}

