// Code generated by gen_clone.go; DO NOT EDIT.
package ast

func (n *ArrayLiteral) Clone() *ArrayLiteral {
	return &ArrayLiteral{Value: *n.Value.Clone(), LeftBracket: n.LeftBracket, RightBracket: n.RightBracket}
}
func (n *ArrayPattern) Clone() *ArrayPattern {
	return &ArrayPattern{Elements: *n.Elements.Clone(), Rest: n.Rest.Clone(), LeftBracket: n.LeftBracket, RightBracket: n.RightBracket}
}
func (n *ArrowFunctionLiteral) Clone() *ArrowFunctionLiteral {
	return &ArrowFunctionLiteral{ParameterList: n.ParameterList.Clone(), Body: n.Body.Clone(), ScopeContext: n.ScopeContext, Start: n.Start, Async: n.Async}
}
func (n *AssignExpression) Clone() *AssignExpression {
	return &AssignExpression{Left: n.Left.Clone(), Right: n.Right.Clone(), Operator: n.Operator}
}
func (n *AwaitExpression) Clone() *AwaitExpression {
	return &AwaitExpression{Argument: n.Argument.Clone(), Await: n.Await}
}
func (n *BadStatement) Clone() *BadStatement {
	return &BadStatement{From: n.From, To: n.To}
}
func (n *BinaryExpression) Clone() *BinaryExpression {
	return &BinaryExpression{Left: n.Left.Clone(), Right: n.Right.Clone(), Operator: n.Operator}
}
func (n *BlockStatement) Clone() *BlockStatement {
	return &BlockStatement{List: *n.List.Clone(), ScopeContext: n.ScopeContext, LeftBrace: n.LeftBrace, RightBrace: n.RightBrace}
}
func (n *BooleanLiteral) Clone() *BooleanLiteral {
	return &BooleanLiteral{Idx: n.Idx, Value: n.Value}
}
func (n *BreakStatement) Clone() *BreakStatement {
	var label *Identifier
	if n.Label != nil {
		label = n.Label.Clone()
	}
	return &BreakStatement{Idx: n.Idx, Label: label}
}
func (n *CallExpression) Clone() *CallExpression {
	return &CallExpression{Callee: n.Callee.Clone(), ArgumentList: *n.ArgumentList.Clone(), LeftParenthesis: n.LeftParenthesis, RightParenthesis: n.RightParenthesis}
}
func (n *CaseStatement) Clone() *CaseStatement {
	var test *Expression
	if n.Test != nil {
		test = n.Test.Clone()
	}
	return &CaseStatement{Case: n.Case, Test: test, Consequent: *n.Consequent.Clone()}
}
func (n *CaseStatements) Clone() *CaseStatements {
	ns := make(CaseStatements, len(*n))
	for i := range *n {
		ns[i] = *(*n)[i].Clone()
	}
	return &ns
}
func (n *CatchStatement) Clone() *CatchStatement {
	var parameter *BindingTarget
	if n.Parameter != nil {
		parameter = n.Parameter.Clone()
	}
	return &CatchStatement{Catch: n.Catch, Parameter: parameter, Body: n.Body.Clone()}
}
func (n *ClassDeclaration) Clone() *ClassDeclaration {
	return &ClassDeclaration{Class: n.Class.Clone()}
}
func (n *ClassElements) Clone() *ClassElements {
	ns := make(ClassElements, len(*n))
	for i := range *n {
		ns[i] = *(*n)[i].Clone()
	}
	return &ns
}
func (n *ClassLiteral) Clone() *ClassLiteral {
	var name *Identifier
	if n.Name != nil {
		name = n.Name.Clone()
	}
	var superclass *Expression
	if n.SuperClass != nil {
		superclass = n.SuperClass.Clone()
	}
	return &ClassLiteral{Name: name, SuperClass: superclass, Body: *n.Body.Clone(), Class: n.Class, RightBrace: n.RightBrace}
}
func (n *ClassStaticBlock) Clone() *ClassStaticBlock {
	return &ClassStaticBlock{Block: n.Block.Clone(), Static: n.Static}
}
func (n *ComputedProperty) Clone() *ComputedProperty {
	return &ComputedProperty{Expr: n.Expr.Clone()}
}
func (n *ConditionalExpression) Clone() *ConditionalExpression {
	return &ConditionalExpression{Test: n.Test.Clone(), Consequent: n.Consequent.Clone(), Alternate: n.Alternate.Clone()}
}
func (n *ContinueStatement) Clone() *ContinueStatement {
	var label *Identifier
	if n.Label != nil {
		label = n.Label.Clone()
	}
	return &ContinueStatement{Idx: n.Idx, Label: label}
}
func (n *DebuggerStatement) Clone() *DebuggerStatement {
	return &DebuggerStatement{Debugger: n.Debugger}
}
func (n *DoWhileStatement) Clone() *DoWhileStatement {
	return &DoWhileStatement{Do: n.Do, Test: n.Test.Clone(), Body: n.Body.Clone()}
}
func (n *EmptyStatement) Clone() *EmptyStatement {
	return &EmptyStatement{Semicolon: n.Semicolon}
}
func (n *ExpressionStatement) Clone() *ExpressionStatement {
	return &ExpressionStatement{Expression: n.Expression.Clone(), Comment: n.Comment}
}
func (n *Expressions) Clone() *Expressions {
	ns := make(Expressions, len(*n))
	for i := range *n {
		ns[i] = *(*n)[i].Clone()
	}
	return &ns
}
func (n *FieldDefinition) Clone() *FieldDefinition {
	var initializer *Expression
	if n.Initializer != nil {
		initializer = n.Initializer.Clone()
	}
	return &FieldDefinition{Key: n.Key.Clone(), Initializer: initializer, Idx: n.Idx, Computed: n.Computed, Static: n.Static}
}
func (n *ForInStatement) Clone() *ForInStatement {
	return &ForInStatement{Into: n.Into.Clone(), Source: n.Source.Clone(), Body: n.Body.Clone(), For: n.For}
}
func (n *ForOfStatement) Clone() *ForOfStatement {
	return &ForOfStatement{Into: n.Into.Clone(), Source: n.Source.Clone(), Body: n.Body.Clone(), For: n.For}
}
func (n *ForStatement) Clone() *ForStatement {
	var initializer *ForLoopInitializer
	if n.Initializer != nil {
		initializer = n.Initializer.Clone()
	}
	return &ForStatement{Initializer: initializer, Update: n.Update.Clone(), Test: n.Test.Clone(), Body: n.Body.Clone(), For: n.For}
}
func (n *FunctionDeclaration) Clone() *FunctionDeclaration {
	return &FunctionDeclaration{Function: n.Function.Clone()}
}
func (n *FunctionLiteral) Clone() *FunctionLiteral {
	var name *Identifier
	if n.Name != nil {
		name = n.Name.Clone()
	}
	return &FunctionLiteral{Name: name, ParameterList: n.ParameterList.Clone(), Body: n.Body.Clone(), ScopeContext: n.ScopeContext, Function: n.Function, Async: n.Async}
}
func (n *Identifier) Clone() *Identifier {
	return &Identifier{Name: n.Name, ScopeContext: n.ScopeContext, Idx: n.Idx}
}
func (n *IfStatement) Clone() *IfStatement {
	var alternate *Statement
	if n.Alternate != nil {
		alternate = n.Alternate.Clone()
	}
	return &IfStatement{If: n.If, Test: n.Test.Clone(), Consequent: n.Consequent.Clone(), Alternate: alternate}
}
func (n *InvalidExpression) Clone() *InvalidExpression {
	return &InvalidExpression{From: n.From, To: n.To}
}
func (n *LabelledStatement) Clone() *LabelledStatement {
	return &LabelledStatement{Label: n.Label.Clone(), Colon: n.Colon, Statement: n.Statement.Clone()}
}
func (n *MemberExpression) Clone() *MemberExpression {
	return &MemberExpression{Object: n.Object.Clone(), Property: n.Property.Clone()}
}
func (n *MetaProperty) Clone() *MetaProperty {
	return &MetaProperty{Meta: n.Meta.Clone(), Idx: n.Idx}
}
func (n *MethodDefinition) Clone() *MethodDefinition {
	return &MethodDefinition{Key: n.Key.Clone(), Kind: n.Kind, Body: n.Body.Clone(), Idx: n.Idx, Computed: n.Computed, Static: n.Static}
}
func (n *NewExpression) Clone() *NewExpression {
	return &NewExpression{ArgumentList: *n.ArgumentList.Clone(), Callee: n.Callee.Clone(), New: n.New, LeftParenthesis: n.LeftParenthesis, RightParenthesis: n.RightParenthesis}
}
func (n *NullLiteral) Clone() *NullLiteral {
	return &NullLiteral{Idx: n.Idx}
}
func (n *NumberLiteral) Clone() *NumberLiteral {
	return &NumberLiteral{Value: n.Value, Raw: n.Raw, Idx: n.Idx}
}
func (n *ObjectLiteral) Clone() *ObjectLiteral {
	return &ObjectLiteral{Value: *n.Value.Clone(), LeftBrace: n.LeftBrace, RightBrace: n.RightBrace}
}
func (n *ObjectPattern) Clone() *ObjectPattern {
	var rest *Expression
	if n.Rest != nil {
		rest = n.Rest.Clone()
	}
	return &ObjectPattern{Properties: *n.Properties.Clone(), Rest: rest, LeftBrace: n.LeftBrace, RightBrace: n.RightBrace}
}
func (n *Optional) Clone() *Optional {
	return &Optional{Expr: n.Expr.Clone()}
}
func (n *OptionalChain) Clone() *OptionalChain {
	return &OptionalChain{Base: n.Base.Clone()}
}
func (n *ParameterList) Clone() *ParameterList {
	var rest *Expression
	if n.Rest != nil {
		rest = n.Rest.Clone()
	}
	return &ParameterList{List: *n.List.Clone(), Rest: rest, Opening: n.Opening, Closing: n.Closing}
}
func (n *PrivateDotExpression) Clone() *PrivateDotExpression {
	return &PrivateDotExpression{Left: n.Left.Clone(), Identifier: n.Identifier.Clone()}
}
func (n *PrivateIdentifier) Clone() *PrivateIdentifier {
	return &PrivateIdentifier{Identifier: n.Identifier.Clone()}
}
func (n *Program) Clone() *Program {
	return &Program{Body: *n.Body.Clone()}
}
func (n *Properties) Clone() *Properties {
	ns := make(Properties, len(*n))
	for i := range *n {
		ns[i] = *(*n)[i].Clone()
	}
	return &ns
}
func (n *PropertyKeyed) Clone() *PropertyKeyed {
	return &PropertyKeyed{Key: n.Key.Clone(), Kind: n.Kind, Value: n.Value.Clone(), Computed: n.Computed}
}
func (n *PropertyShort) Clone() *PropertyShort {
	return &PropertyShort{Name: n.Name.Clone(), Initializer: n.Initializer.Clone()}
}
func (n *RegExpLiteral) Clone() *RegExpLiteral {
	return &RegExpLiteral{Literal: n.Literal, Pattern: n.Pattern, Flags: n.Flags, Idx: n.Idx}
}
func (n *ReturnStatement) Clone() *ReturnStatement {
	var argument *Expression
	if n.Argument != nil {
		argument = n.Argument.Clone()
	}
	return &ReturnStatement{Return: n.Return, Argument: argument}
}
func (n *SequenceExpression) Clone() *SequenceExpression {
	return &SequenceExpression{Sequence: *n.Sequence.Clone()}
}
func (n *SpreadElement) Clone() *SpreadElement {
	return &SpreadElement{Expression: n.Expression.Clone()}
}
func (n *Statements) Clone() *Statements {
	ns := make(Statements, len(*n))
	for i := range *n {
		ns[i] = *(*n)[i].Clone()
	}
	return &ns
}
func (n *StringLiteral) Clone() *StringLiteral {
	return &StringLiteral{Value: n.Value, Raw: n.Raw, Idx: n.Idx}
}
func (n *SuperExpression) Clone() *SuperExpression {
	return &SuperExpression{Idx: n.Idx}
}
func (n *SwitchStatement) Clone() *SwitchStatement {
	return &SwitchStatement{Body: *n.Body.Clone(), Discriminant: n.Discriminant.Clone(), Default: n.Default, Switch: n.Switch}
}
func (n *TemplateElement) Clone() *TemplateElement {
	return &TemplateElement{Literal: n.Literal, Parsed: n.Parsed, Idx: n.Idx, Valid: n.Valid}
}
func (n *TemplateElements) Clone() *TemplateElements {
	ns := make(TemplateElements, len(*n))
	for i := range *n {
		ns[i] = *(*n)[i].Clone()
	}
	return &ns
}
func (n *TemplateLiteral) Clone() *TemplateLiteral {
	var tag *Expression
	if n.Tag != nil {
		tag = n.Tag.Clone()
	}
	return &TemplateLiteral{Tag: tag, Elements: *n.Elements.Clone(), Expressions: *n.Expressions.Clone(), OpenQuote: n.OpenQuote, CloseQuote: n.CloseQuote}
}
func (n *ThisExpression) Clone() *ThisExpression {
	return &ThisExpression{Idx: n.Idx}
}
func (n *ThrowStatement) Clone() *ThrowStatement {
	return &ThrowStatement{Argument: n.Argument.Clone(), Throw: n.Throw}
}
func (n *TryStatement) Clone() *TryStatement {
	var catch *CatchStatement
	if n.Catch != nil {
		catch = n.Catch.Clone()
	}
	var finally *BlockStatement
	if n.Finally != nil {
		finally = n.Finally.Clone()
	}
	return &TryStatement{Body: n.Body.Clone(), Catch: catch, Finally: finally, Try: n.Try}
}
func (n *UnaryExpression) Clone() *UnaryExpression {
	return &UnaryExpression{Operand: n.Operand.Clone(), Idx: n.Idx, Operator: n.Operator}
}
func (n *UpdateExpression) Clone() *UpdateExpression {
	return &UpdateExpression{Operand: n.Operand.Clone(), Idx: n.Idx, Operator: n.Operator, Postfix: n.Postfix}
}
func (n *VariableDeclaration) Clone() *VariableDeclaration {
	return &VariableDeclaration{List: *n.List.Clone(), Comment: n.Comment, Idx: n.Idx, Token: n.Token}
}
func (n *VariableDeclarator) Clone() *VariableDeclarator {
	var initializer *Expression
	if n.Initializer != nil {
		initializer = n.Initializer.Clone()
	}
	return &VariableDeclarator{Target: n.Target.Clone(), Initializer: initializer}
}
func (n *VariableDeclarators) Clone() *VariableDeclarators {
	ns := make(VariableDeclarators, len(*n))
	for i := range *n {
		ns[i] = *(*n)[i].Clone()
	}
	return &ns
}
func (n *WhileStatement) Clone() *WhileStatement {
	return &WhileStatement{Test: n.Test.Clone(), Body: n.Body.Clone(), While: n.While}
}
func (n *WithStatement) Clone() *WithStatement {
	return &WithStatement{Object: n.Object.Clone(), Body: n.Body.Clone(), With: n.With}
}
func (n *YieldExpression) Clone() *YieldExpression {
	return &YieldExpression{Yield: n.Yield, Argument: n.Argument.Clone(), Delegate: n.Delegate}
}

func (n *BindingTarget) Clone() *BindingTarget {
	switch n.kind {
	case BindingTargetArrPat:
		c := (*ArrayPattern)(n.ptr).Clone()
		r := NewArrPatBindingTarget(c)
		return &r
	case BindingTargetIdent:
		c := (*Identifier)(n.ptr).Clone()
		r := NewIdentBindingTarget(c)
		return &r
	case BindingTargetInvalid:
		r := *n
		return &r
	case BindingTargetMember:
		c := (*MemberExpression)(n.ptr).Clone()
		r := NewMemberBindingTarget(c)
		return &r
	case BindingTargetObjPat:
		c := (*ObjectPattern)(n.ptr).Clone()
		r := NewObjPatBindingTarget(c)
		return &r
	}
	r := BindingTarget{}
	return &r
}

func (n *ClassElement) Clone() *ClassElement {
	switch n.kind {
	case ClassElemField:
		c := (*FieldDefinition)(n.ptr).Clone()
		r := NewFieldClassElem(c)
		return &r
	case ClassElemMethod:
		c := (*MethodDefinition)(n.ptr).Clone()
		r := NewMethodClassElem(c)
		return &r
	case ClassElemStaticBlock:
		c := (*ClassStaticBlock)(n.ptr).Clone()
		r := NewStaticBlockClassElem(c)
		return &r
	}
	r := ClassElement{}
	return &r
}

func (n *ConciseBody) Clone() *ConciseBody {
	switch n.kind {
	case ConciseBodyBlock:
		c := (*BlockStatement)(n.ptr).Clone()
		r := NewBlockConciseBody(c)
		return &r
	case ConciseBodyExpr:
		c := (*Expression)(n.ptr).Clone()
		r := NewExprConciseBody(c)
		return &r
	}
	r := ConciseBody{}
	return &r
}

func (n *Expression) Clone() *Expression {
	switch n.kind {
	case ExprArrLit:
		c := (*ArrayLiteral)(n.ptr).Clone()
		r := NewArrLitExpr(c)
		return &r
	case ExprArrPat:
		c := (*ArrayPattern)(n.ptr).Clone()
		r := NewArrPatExpr(c)
		return &r
	case ExprArrowFuncLit:
		c := (*ArrowFunctionLiteral)(n.ptr).Clone()
		r := NewArrowFuncLitExpr(c)
		return &r
	case ExprAssign:
		c := (*AssignExpression)(n.ptr).Clone()
		r := NewAssignExpr(c)
		return &r
	case ExprAwait:
		c := (*AwaitExpression)(n.ptr).Clone()
		r := NewAwaitExpr(c)
		return &r
	case ExprBinary:
		c := (*BinaryExpression)(n.ptr).Clone()
		r := NewBinaryExpr(c)
		return &r
	case ExprBoolLit:
		r := *n
		return &r
	case ExprCall:
		c := (*CallExpression)(n.ptr).Clone()
		r := NewCallExpr(c)
		return &r
	case ExprClassLit:
		c := (*ClassLiteral)(n.ptr).Clone()
		r := NewClassLitExpr(c)
		return &r
	case ExprConditional:
		c := (*ConditionalExpression)(n.ptr).Clone()
		r := NewConditionalExpr(c)
		return &r
	case ExprFuncLit:
		c := (*FunctionLiteral)(n.ptr).Clone()
		r := NewFuncLitExpr(c)
		return &r
	case ExprIdent:
		c := (*Identifier)(n.ptr).Clone()
		r := NewIdentExpr(c)
		return &r
	case ExprInvalid:
		r := *n
		return &r
	case ExprKeyed:
		c := (*PropertyKeyed)(n.ptr).Clone()
		r := NewKeyedExpr(c)
		return &r
	case ExprMember:
		c := (*MemberExpression)(n.ptr).Clone()
		r := NewMemberExpr(c)
		return &r
	case ExprMetaProp:
		c := (*MetaProperty)(n.ptr).Clone()
		r := NewMetaPropExpr(c)
		return &r
	case ExprNew:
		c := (*NewExpression)(n.ptr).Clone()
		r := NewNewExpr(c)
		return &r
	case ExprNullLit:
		r := *n
		return &r
	case ExprNumLit:
		c := (*NumberLiteral)(n.ptr).Clone()
		r := NewNumLitExpr(c)
		return &r
	case ExprObjLit:
		c := (*ObjectLiteral)(n.ptr).Clone()
		r := NewObjLitExpr(c)
		return &r
	case ExprObjPat:
		c := (*ObjectPattern)(n.ptr).Clone()
		r := NewObjPatExpr(c)
		return &r
	case ExprOptChain:
		c := (*OptionalChain)(n.ptr).Clone()
		r := NewOptChainExpr(c)
		return &r
	case ExprOptional:
		c := (*Optional)(n.ptr).Clone()
		r := NewOptionalExpr(c)
		return &r
	case ExprPrivDot:
		c := (*PrivateDotExpression)(n.ptr).Clone()
		r := NewPrivDotExpr(c)
		return &r
	case ExprPrivIdent:
		c := (*PrivateIdentifier)(n.ptr).Clone()
		r := NewPrivIdentExpr(c)
		return &r
	case ExprRegExpLit:
		c := (*RegExpLiteral)(n.ptr).Clone()
		r := NewRegExpLitExpr(c)
		return &r
	case ExprSequence:
		c := (*SequenceExpression)(n.ptr).Clone()
		r := NewSequenceExpr(c)
		return &r
	case ExprShort:
		c := (*PropertyShort)(n.ptr).Clone()
		r := NewShortExpr(c)
		return &r
	case ExprSpread:
		c := (*SpreadElement)(n.ptr).Clone()
		r := NewSpreadExpr(c)
		return &r
	case ExprStrLit:
		c := (*StringLiteral)(n.ptr).Clone()
		r := NewStrLitExpr(c)
		return &r
	case ExprSuper:
		r := *n
		return &r
	case ExprThis:
		r := *n
		return &r
	case ExprTmplLit:
		c := (*TemplateLiteral)(n.ptr).Clone()
		r := NewTmplLitExpr(c)
		return &r
	case ExprUnary:
		c := (*UnaryExpression)(n.ptr).Clone()
		r := NewUnaryExpr(c)
		return &r
	case ExprUpdate:
		c := (*UpdateExpression)(n.ptr).Clone()
		r := NewUpdateExpr(c)
		return &r
	case ExprVarDeclarator:
		c := (*VariableDeclarator)(n.ptr).Clone()
		r := NewVarDeclaratorExpr(c)
		return &r
	case ExprYield:
		c := (*YieldExpression)(n.ptr).Clone()
		r := NewYieldExpr(c)
		return &r
	}
	r := Expression{}
	return &r
}

func (n *ForInto) Clone() *ForInto {
	switch n.kind {
	case ForIntoExpr:
		c := (*Expression)(n.ptr).Clone()
		r := NewExprForInto(c)
		return &r
	case ForIntoVarDecl:
		c := (*VariableDeclaration)(n.ptr).Clone()
		r := NewVarDeclForInto(c)
		return &r
	}
	r := ForInto{}
	return &r
}

func (n *ForLoopInitializer) Clone() *ForLoopInitializer {
	switch n.kind {
	case ForInitExpr:
		c := (*Expression)(n.ptr).Clone()
		r := NewExprForInit(c)
		return &r
	case ForInitVarDecl:
		c := (*VariableDeclaration)(n.ptr).Clone()
		r := NewVarDeclForInit(c)
		return &r
	}
	r := ForLoopInitializer{}
	return &r
}

func (n *MemberProperty) Clone() *MemberProperty {
	switch n.kind {
	case MemPropComputed:
		c := (*ComputedProperty)(n.ptr).Clone()
		r := NewComputedMemProp(c)
		return &r
	case MemPropIdent:
		c := (*Identifier)(n.ptr).Clone()
		r := NewIdentMemProp(c)
		return &r
	}
	r := MemberProperty{}
	return &r
}

func (n *Property) Clone() *Property {
	switch n.kind {
	case PropKeyed:
		c := (*PropertyKeyed)(n.ptr).Clone()
		r := NewKeyedProp(c)
		return &r
	case PropShort:
		c := (*PropertyShort)(n.ptr).Clone()
		r := NewShortProp(c)
		return &r
	case PropSpread:
		c := (*SpreadElement)(n.ptr).Clone()
		r := NewSpreadProp(c)
		return &r
	}
	r := Property{}
	return &r
}

func (n *Statement) Clone() *Statement {
	switch n.kind {
	case StmtBad:
		r := *n
		return &r
	case StmtBlock:
		c := (*BlockStatement)(n.ptr).Clone()
		r := NewBlockStmt(c)
		return &r
	case StmtBreak:
		c := (*BreakStatement)(n.ptr).Clone()
		r := NewBreakStmt(c)
		return &r
	case StmtCase:
		c := (*CaseStatement)(n.ptr).Clone()
		r := NewCaseStmt(c)
		return &r
	case StmtCatch:
		c := (*CatchStatement)(n.ptr).Clone()
		r := NewCatchStmt(c)
		return &r
	case StmtClassDecl:
		c := (*ClassDeclaration)(n.ptr).Clone()
		r := NewClassDeclStmt(c)
		return &r
	case StmtContinue:
		c := (*ContinueStatement)(n.ptr).Clone()
		r := NewContinueStmt(c)
		return &r
	case StmtDebugger:
		r := *n
		return &r
	case StmtDoWhile:
		c := (*DoWhileStatement)(n.ptr).Clone()
		r := NewDoWhileStmt(c)
		return &r
	case StmtEmpty:
		r := *n
		return &r
	case StmtExpression:
		c := (*ExpressionStatement)(n.ptr).Clone()
		r := NewExpressionStmt(c)
		return &r
	case StmtFor:
		c := (*ForStatement)(n.ptr).Clone()
		r := NewForStmt(c)
		return &r
	case StmtForIn:
		c := (*ForInStatement)(n.ptr).Clone()
		r := NewForInStmt(c)
		return &r
	case StmtForOf:
		c := (*ForOfStatement)(n.ptr).Clone()
		r := NewForOfStmt(c)
		return &r
	case StmtFuncDecl:
		c := (*FunctionDeclaration)(n.ptr).Clone()
		r := NewFuncDeclStmt(c)
		return &r
	case StmtIf:
		c := (*IfStatement)(n.ptr).Clone()
		r := NewIfStmt(c)
		return &r
	case StmtLabelled:
		c := (*LabelledStatement)(n.ptr).Clone()
		r := NewLabelledStmt(c)
		return &r
	case StmtReturn:
		c := (*ReturnStatement)(n.ptr).Clone()
		r := NewReturnStmt(c)
		return &r
	case StmtSwitch:
		c := (*SwitchStatement)(n.ptr).Clone()
		r := NewSwitchStmt(c)
		return &r
	case StmtThrow:
		c := (*ThrowStatement)(n.ptr).Clone()
		r := NewThrowStmt(c)
		return &r
	case StmtTry:
		c := (*TryStatement)(n.ptr).Clone()
		r := NewTryStmt(c)
		return &r
	case StmtVarDecl:
		c := (*VariableDeclaration)(n.ptr).Clone()
		r := NewVarDeclStmt(c)
		return &r
	case StmtWhile:
		c := (*WhileStatement)(n.ptr).Clone()
		r := NewWhileStmt(c)
		return &r
	case StmtWith:
		c := (*WithStatement)(n.ptr).Clone()
		r := NewWithStmt(c)
		return &r
	}
	r := Statement{}
	return &r
}
