// Code generated by gen_match.go; DO NOT EDIT.
package ast

type Matcher interface {
	match(actual any) bool
}

func Match(actual, pattern any) bool {
	if pattern == nil {
		return true
	}
	m, ok := pattern.(Matcher)
	if !ok {
		return false
	}
	return m.match(actual)
}

type Any struct{}

func AnyNode() *Any { return &Any{} }

type Capture struct{ Out any }

func CaptureNode(out any) *Capture { return &Capture{Out: out} }

func (p *Any) match(actual any) bool { return true }

func (p *Capture) match(actual any) bool { return bindCapture(actual, p.Out) }

func bindCapture(actual any, out any) bool {
	if out == nil {
		return false
	}
	if dst, ok := out.(**ArrayLiteral); ok {
		v, ok := actual.(*ArrayLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ArrayPattern); ok {
		v, ok := actual.(*ArrayPattern)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ArrowFunctionLiteral); ok {
		v, ok := actual.(*ArrowFunctionLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**AssignExpression); ok {
		v, ok := actual.(*AssignExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**AwaitExpression); ok {
		v, ok := actual.(*AwaitExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**BadStatement); ok {
		v, ok := actual.(*BadStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**BinaryExpression); ok {
		v, ok := actual.(*BinaryExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**BindingTarget); ok {
		v, ok := actual.(*BindingTarget)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**BlockStatement); ok {
		v, ok := actual.(*BlockStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**BooleanLiteral); ok {
		v, ok := actual.(*BooleanLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**BreakStatement); ok {
		v, ok := actual.(*BreakStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**CallExpression); ok {
		v, ok := actual.(*CallExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**CaseStatement); ok {
		v, ok := actual.(*CaseStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**CatchStatement); ok {
		v, ok := actual.(*CatchStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ClassDeclaration); ok {
		v, ok := actual.(*ClassDeclaration)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ClassElement); ok {
		v, ok := actual.(*ClassElement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ClassLiteral); ok {
		v, ok := actual.(*ClassLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ClassStaticBlock); ok {
		v, ok := actual.(*ClassStaticBlock)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ComputedProperty); ok {
		v, ok := actual.(*ComputedProperty)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ConciseBody); ok {
		v, ok := actual.(*ConciseBody)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ConditionalExpression); ok {
		v, ok := actual.(*ConditionalExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ContinueStatement); ok {
		v, ok := actual.(*ContinueStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**DebuggerStatement); ok {
		v, ok := actual.(*DebuggerStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**DoWhileStatement); ok {
		v, ok := actual.(*DoWhileStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**EmptyStatement); ok {
		v, ok := actual.(*EmptyStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**Expression); ok {
		v, ok := actual.(*Expression)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ExpressionStatement); ok {
		v, ok := actual.(*ExpressionStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**FieldDefinition); ok {
		v, ok := actual.(*FieldDefinition)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ForInStatement); ok {
		v, ok := actual.(*ForInStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ForInto); ok {
		v, ok := actual.(*ForInto)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ForLoopInitializer); ok {
		v, ok := actual.(*ForLoopInitializer)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ForOfStatement); ok {
		v, ok := actual.(*ForOfStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ForStatement); ok {
		v, ok := actual.(*ForStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**FunctionDeclaration); ok {
		v, ok := actual.(*FunctionDeclaration)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**FunctionLiteral); ok {
		v, ok := actual.(*FunctionLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**Id); ok {
		v, ok := actual.(*Id)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**Identifier); ok {
		v, ok := actual.(*Identifier)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**IfStatement); ok {
		v, ok := actual.(*IfStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**InvalidExpression); ok {
		v, ok := actual.(*InvalidExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**LabelledStatement); ok {
		v, ok := actual.(*LabelledStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**MemberExpression); ok {
		v, ok := actual.(*MemberExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**MemberProperty); ok {
		v, ok := actual.(*MemberProperty)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**MetaProperty); ok {
		v, ok := actual.(*MetaProperty)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**MethodDefinition); ok {
		v, ok := actual.(*MethodDefinition)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**NewExpression); ok {
		v, ok := actual.(*NewExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**NullLiteral); ok {
		v, ok := actual.(*NullLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**NumberLiteral); ok {
		v, ok := actual.(*NumberLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ObjectLiteral); ok {
		v, ok := actual.(*ObjectLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ObjectPattern); ok {
		v, ok := actual.(*ObjectPattern)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**Optional); ok {
		v, ok := actual.(*Optional)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**OptionalChain); ok {
		v, ok := actual.(*OptionalChain)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ParameterList); ok {
		v, ok := actual.(*ParameterList)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**PrivateDotExpression); ok {
		v, ok := actual.(*PrivateDotExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**PrivateIdentifier); ok {
		v, ok := actual.(*PrivateIdentifier)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**Program); ok {
		v, ok := actual.(*Program)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**Property); ok {
		v, ok := actual.(*Property)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**PropertyKeyed); ok {
		v, ok := actual.(*PropertyKeyed)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**PropertyShort); ok {
		v, ok := actual.(*PropertyShort)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**RegExpLiteral); ok {
		v, ok := actual.(*RegExpLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ReturnStatement); ok {
		v, ok := actual.(*ReturnStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**SequenceExpression); ok {
		v, ok := actual.(*SequenceExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**SpreadElement); ok {
		v, ok := actual.(*SpreadElement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**Statement); ok {
		v, ok := actual.(*Statement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**StringLiteral); ok {
		v, ok := actual.(*StringLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**SuperExpression); ok {
		v, ok := actual.(*SuperExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**SwitchStatement); ok {
		v, ok := actual.(*SwitchStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**TemplateElement); ok {
		v, ok := actual.(*TemplateElement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**TemplateLiteral); ok {
		v, ok := actual.(*TemplateLiteral)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ThisExpression); ok {
		v, ok := actual.(*ThisExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**ThrowStatement); ok {
		v, ok := actual.(*ThrowStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**TryStatement); ok {
		v, ok := actual.(*TryStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**UnaryExpression); ok {
		v, ok := actual.(*UnaryExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**UpdateExpression); ok {
		v, ok := actual.(*UpdateExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**VariableDeclaration); ok {
		v, ok := actual.(*VariableDeclaration)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**VariableDeclarator); ok {
		v, ok := actual.(*VariableDeclarator)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**WhileStatement); ok {
		v, ok := actual.(*WhileStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**WithStatement); ok {
		v, ok := actual.(*WithStatement)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	if dst, ok := out.(**YieldExpression); ok {
		v, ok := actual.(*YieldExpression)
		if !ok {
			return false
		}
		*dst = v
		return true
	}
	return false
}

func (*Any) Idx0() Idx                 { return 0 }
func (*Any) Idx1() Idx                 { return 0 }
func (*Any) VisitWith(Visitor)         {}
func (*Any) VisitChildrenWith(Visitor) {}
func (*Any) _expr()                    {}
func (*Any) _stmt()                    {}

func (*Capture) Idx0() Idx                 { return 0 }
func (*Capture) Idx1() Idx                 { return 0 }
func (*Capture) VisitWith(Visitor)         {}
func (*Capture) VisitChildrenWith(Visitor) {}
func (*Capture) _expr()                    {}
func (*Capture) _stmt()                    {}

func matchCaseStatements(a, p CaseStatements) bool {
	if len(a) != len(p) {
		return false
	}
	for i := 0; i < len(p); i++ {
		if !((&p[i]).match(&a[i])) {
			return false
		}
	}
	return true
}

func matchClassElements(a, p ClassElements) bool {
	if len(a) != len(p) {
		return false
	}
	for i := 0; i < len(p); i++ {
		if !((&p[i]).match(&a[i])) {
			return false
		}
	}
	return true
}

func matchExpressions(a, p Expressions) bool {
	if len(a) != len(p) {
		return false
	}
	for i := 0; i < len(p); i++ {
		if !((&p[i]).match(&a[i])) {
			return false
		}
	}
	return true
}

func matchProperties(a, p Properties) bool {
	if len(a) != len(p) {
		return false
	}
	for i := 0; i < len(p); i++ {
		if !((&p[i]).match(&a[i])) {
			return false
		}
	}
	return true
}

func matchStatements(a, p Statements) bool {
	if len(a) != len(p) {
		return false
	}
	for i := 0; i < len(p); i++ {
		if !((&p[i]).match(&a[i])) {
			return false
		}
	}
	return true
}

func matchTemplateElements(a, p TemplateElements) bool {
	if len(a) != len(p) {
		return false
	}
	for i := 0; i < len(p); i++ {
		if !((&p[i]).match(&a[i])) {
			return false
		}
	}
	return true
}

func matchVariableDeclarators(a, p VariableDeclarators) bool {
	if len(a) != len(p) {
		return false
	}
	for i := 0; i < len(p); i++ {
		if !((&p[i]).match(&a[i])) {
			return false
		}
	}
	return true
}

func (p *ArrayLiteral) match(actual any) bool {
	a, ok := actual.(*ArrayLiteral)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpressions(a.Value, p.Value)) {
		return false
	}
	return true
}

func (p *ArrayPattern) match(actual any) bool {
	a, ok := actual.(*ArrayPattern)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpressions(a.Elements, p.Elements)) {
		return false
	}
	if !((p.Rest == nil && a.Rest == nil) || (p.Rest != nil && (p.Rest).match(a.Rest))) {
		return false
	}
	return true
}

func (p *ArrowFunctionLiteral) match(actual any) bool {
	a, ok := actual.(*ArrowFunctionLiteral)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((&p.ParameterList).match(&a.ParameterList)) {
		return false
	}
	if !((p.Body == nil && a.Body == nil) || (p.Body != nil && (p.Body).match(a.Body))) {
		return false
	}
	if !(a.Async == p.Async) {
		return false
	}
	return true
}

func (p *AssignExpression) match(actual any) bool {
	a, ok := actual.(*AssignExpression)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Operator == p.Operator) {
		return false
	}
	if !((p.Left == nil && a.Left == nil) || (p.Left != nil && (p.Left).match(a.Left))) {
		return false
	}
	if !((p.Right == nil && a.Right == nil) || (p.Right != nil && (p.Right).match(a.Right))) {
		return false
	}
	return true
}

func (p *AwaitExpression) match(actual any) bool {
	a, ok := actual.(*AwaitExpression)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Argument == nil && a.Argument == nil) || (p.Argument != nil && (p.Argument).match(a.Argument))) {
		return false
	}
	return true
}

func (p *BadStatement) match(actual any) bool {
	a, ok := actual.(*BadStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	return true
}

func (p *BinaryExpression) match(actual any) bool {
	a, ok := actual.(*BinaryExpression)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Operator == p.Operator) {
		return false
	}
	if !((p.Left == nil && a.Left == nil) || (p.Left != nil && (p.Left).match(a.Left))) {
		return false
	}
	if !((p.Right == nil && a.Right == nil) || (p.Right != nil && (p.Right).match(a.Right))) {
		return false
	}
	return true
}

func (p *BindingTarget) match(actual any) bool {
	a, ok := actual.(*BindingTarget)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(Match(a.Target, p.Target)) {
		return false
	}
	return true
}

func (p *BlockStatement) match(actual any) bool {
	a, ok := actual.(*BlockStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchStatements(a.List, p.List)) {
		return false
	}
	return true
}

func (p *BooleanLiteral) match(actual any) bool {
	a, ok := actual.(*BooleanLiteral)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Value == p.Value) {
		return false
	}
	return true
}

func (p *BreakStatement) match(actual any) bool {
	a, ok := actual.(*BreakStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Label == nil && a.Label == nil) || (p.Label != nil && (p.Label).match(a.Label))) {
		return false
	}
	return true
}

func (p *CallExpression) match(actual any) bool {
	a, ok := actual.(*CallExpression)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Callee == nil && a.Callee == nil) || (p.Callee != nil && (p.Callee).match(a.Callee))) {
		return false
	}
	if !(matchExpressions(a.ArgumentList, p.ArgumentList)) {
		return false
	}
	return true
}

func (p *CaseStatement) match(actual any) bool {
	a, ok := actual.(*CaseStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Test == nil && a.Test == nil) || (p.Test != nil && (p.Test).match(a.Test))) {
		return false
	}
	if !(matchStatements(a.Consequent, p.Consequent)) {
		return false
	}
	return true
}

func (p *CatchStatement) match(actual any) bool {
	a, ok := actual.(*CatchStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Parameter == nil && a.Parameter == nil) || (p.Parameter != nil && (p.Parameter).match(a.Parameter))) {
		return false
	}
	if !((p.Body == nil && a.Body == nil) || (p.Body != nil && (p.Body).match(a.Body))) {
		return false
	}
	return true
}

func (p *ClassDeclaration) match(actual any) bool {
	a, ok := actual.(*ClassDeclaration)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Class == nil && a.Class == nil) || (p.Class != nil && (p.Class).match(a.Class))) {
		return false
	}
	return true
}

func (p *ClassElement) match(actual any) bool {
	a, ok := actual.(*ClassElement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(Match(a.Element, p.Element)) {
		return false
	}
	return true
}

func (p *ClassLiteral) match(actual any) bool {
	a, ok := actual.(*ClassLiteral)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Name == nil && a.Name == nil) || (p.Name != nil && (p.Name).match(a.Name))) {
		return false
	}
	if !((p.SuperClass == nil && a.SuperClass == nil) || (p.SuperClass != nil && (p.SuperClass).match(a.SuperClass))) {
		return false
	}
	if !(matchClassElements(a.Body, p.Body)) {
		return false
	}
	return true
}

func (p *ClassStaticBlock) match(actual any) bool {
	a, ok := actual.(*ClassStaticBlock)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Block == nil && a.Block == nil) || (p.Block != nil && (p.Block).match(a.Block))) {
		return false
	}
	return true
}

func (p *ComputedProperty) match(actual any) bool {
	a, ok := actual.(*ComputedProperty)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Expr == nil && a.Expr == nil) || (p.Expr != nil && (p.Expr).match(a.Expr))) {
		return false
	}
	return true
}

func (p *ConciseBody) match(actual any) bool {
	a, ok := actual.(*ConciseBody)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(Match(a.Body, p.Body)) {
		return false
	}
	return true
}

func (p *ConditionalExpression) match(actual any) bool {
	a, ok := actual.(*ConditionalExpression)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Test == nil && a.Test == nil) || (p.Test != nil && (p.Test).match(a.Test))) {
		return false
	}
	if !((p.Consequent == nil && a.Consequent == nil) || (p.Consequent != nil && (p.Consequent).match(a.Consequent))) {
		return false
	}
	if !((p.Alternate == nil && a.Alternate == nil) || (p.Alternate != nil && (p.Alternate).match(a.Alternate))) {
		return false
	}
	return true
}

func (p *ContinueStatement) match(actual any) bool {
	a, ok := actual.(*ContinueStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Label == nil && a.Label == nil) || (p.Label != nil && (p.Label).match(a.Label))) {
		return false
	}
	return true
}

func (p *DebuggerStatement) match(actual any) bool {
	a, ok := actual.(*DebuggerStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	return true
}

func (p *DoWhileStatement) match(actual any) bool {
	a, ok := actual.(*DoWhileStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Test == nil && a.Test == nil) || (p.Test != nil && (p.Test).match(a.Test))) {
		return false
	}
	if !((p.Body == nil && a.Body == nil) || (p.Body != nil && (p.Body).match(a.Body))) {
		return false
	}
	return true
}

func (p *EmptyStatement) match(actual any) bool {
	a, ok := actual.(*EmptyStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	return true
}

func (p *Expression) match(actual any) bool {
	a, ok := actual.(*Expression)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(Match(a.Expr, p.Expr)) {
		return false
	}
	return true
}

func (p *ExpressionStatement) match(actual any) bool {
	a, ok := actual.(*ExpressionStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Expression == nil && a.Expression == nil) || (p.Expression != nil && (p.Expression).match(a.Expression))) {
		return false
	}
	if !(a.Comment == p.Comment) {
		return false
	}
	return true
}

func (p *FieldDefinition) match(actual any) bool {
	a, ok := actual.(*FieldDefinition)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Key == nil && a.Key == nil) || (p.Key != nil && (p.Key).match(a.Key))) {
		return false
	}
	if !((p.Initializer == nil && a.Initializer == nil) || (p.Initializer != nil && (p.Initializer).match(a.Initializer))) {
		return false
	}
	if !(a.Computed == p.Computed) {
		return false
	}
	if !(a.Static == p.Static) {
		return false
	}
	return true
}

func (p *ForInStatement) match(actual any) bool {
	a, ok := actual.(*ForInStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Into == nil && a.Into == nil) || (p.Into != nil && (p.Into).match(a.Into))) {
		return false
	}
	if !((p.Source == nil && a.Source == nil) || (p.Source != nil && (p.Source).match(a.Source))) {
		return false
	}
	if !((p.Body == nil && a.Body == nil) || (p.Body != nil && (p.Body).match(a.Body))) {
		return false
	}
	return true
}

func (p *ForInto) match(actual any) bool {
	a, ok := actual.(*ForInto)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(Match(a.Into, p.Into)) {
		return false
	}
	return true
}

func (p *ForLoopInitializer) match(actual any) bool {
	a, ok := actual.(*ForLoopInitializer)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(Match(a.Initializer, p.Initializer)) {
		return false
	}
	return true
}

func (p *ForOfStatement) match(actual any) bool {
	a, ok := actual.(*ForOfStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Into == nil && a.Into == nil) || (p.Into != nil && (p.Into).match(a.Into))) {
		return false
	}
	if !((p.Source == nil && a.Source == nil) || (p.Source != nil && (p.Source).match(a.Source))) {
		return false
	}
	if !((p.Body == nil && a.Body == nil) || (p.Body != nil && (p.Body).match(a.Body))) {
		return false
	}
	return true
}

func (p *ForStatement) match(actual any) bool {
	a, ok := actual.(*ForStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Initializer == nil && a.Initializer == nil) || (p.Initializer != nil && (p.Initializer).match(a.Initializer))) {
		return false
	}
	if !((p.Update == nil && a.Update == nil) || (p.Update != nil && (p.Update).match(a.Update))) {
		return false
	}
	if !((p.Test == nil && a.Test == nil) || (p.Test != nil && (p.Test).match(a.Test))) {
		return false
	}
	if !((p.Body == nil && a.Body == nil) || (p.Body != nil && (p.Body).match(a.Body))) {
		return false
	}
	return true
}

func (p *FunctionDeclaration) match(actual any) bool {
	a, ok := actual.(*FunctionDeclaration)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Function == nil && a.Function == nil) || (p.Function != nil && (p.Function).match(a.Function))) {
		return false
	}
	return true
}

func (p *FunctionLiteral) match(actual any) bool {
	a, ok := actual.(*FunctionLiteral)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Name == nil && a.Name == nil) || (p.Name != nil && (p.Name).match(a.Name))) {
		return false
	}
	if !((&p.ParameterList).match(&a.ParameterList)) {
		return false
	}
	if !((p.Body == nil && a.Body == nil) || (p.Body != nil && (p.Body).match(a.Body))) {
		return false
	}
	if !(a.Async == p.Async) {
		return false
	}
	if !(a.Generator == p.Generator) {
		return false
	}
	return true
}

func (p *Id) match(actual any) bool {
	a, ok := actual.(*Id)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Name == p.Name) {
		return false
	}
	return true
}

func (p *Identifier) match(actual any) bool {
	a, ok := actual.(*Identifier)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Name == p.Name) {
		return false
	}
	return true
}

func (p *IfStatement) match(actual any) bool {
	a, ok := actual.(*IfStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Test == nil && a.Test == nil) || (p.Test != nil && (p.Test).match(a.Test))) {
		return false
	}
	if !((p.Consequent == nil && a.Consequent == nil) || (p.Consequent != nil && (p.Consequent).match(a.Consequent))) {
		return false
	}
	if !((p.Alternate == nil && a.Alternate == nil) || (p.Alternate != nil && (p.Alternate).match(a.Alternate))) {
		return false
	}
	return true
}

func (p *InvalidExpression) match(actual any) bool {
	a, ok := actual.(*InvalidExpression)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	return true
}

func (p *LabelledStatement) match(actual any) bool {
	a, ok := actual.(*LabelledStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Label == nil && a.Label == nil) || (p.Label != nil && (p.Label).match(a.Label))) {
		return false
	}
	if !((p.Statement == nil && a.Statement == nil) || (p.Statement != nil && (p.Statement).match(a.Statement))) {
		return false
	}
	return true
}

func (p *MemberExpression) match(actual any) bool {
	a, ok := actual.(*MemberExpression)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Object == nil && a.Object == nil) || (p.Object != nil && (p.Object).match(a.Object))) {
		return false
	}
	if !((p.Property == nil && a.Property == nil) || (p.Property != nil && (p.Property).match(a.Property))) {
		return false
	}
	return true
}

func (p *MemberProperty) match(actual any) bool {
	a, ok := actual.(*MemberProperty)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(Match(a.Prop, p.Prop)) {
		return false
	}
	return true
}

func (p *MetaProperty) match(actual any) bool {
	a, ok := actual.(*MetaProperty)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Meta == nil && a.Meta == nil) || (p.Meta != nil && (p.Meta).match(a.Meta))) {
		return false
	}
	if !((p.Property == nil && a.Property == nil) || (p.Property != nil && (p.Property).match(a.Property))) {
		return false
	}
	return true
}

func (p *MethodDefinition) match(actual any) bool {
	a, ok := actual.(*MethodDefinition)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Key == nil && a.Key == nil) || (p.Key != nil && (p.Key).match(a.Key))) {
		return false
	}
	if !(a.Kind == p.Kind) {
		return false
	}
	if !((p.Body == nil && a.Body == nil) || (p.Body != nil && (p.Body).match(a.Body))) {
		return false
	}
	if !(a.Computed == p.Computed) {
		return false
	}
	if !(a.Static == p.Static) {
		return false
	}
	return true
}

func (p *NewExpression) match(actual any) bool {
	a, ok := actual.(*NewExpression)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Callee == nil && a.Callee == nil) || (p.Callee != nil && (p.Callee).match(a.Callee))) {
		return false
	}
	if !(matchExpressions(a.ArgumentList, p.ArgumentList)) {
		return false
	}
	return true
}

func (p *NullLiteral) match(actual any) bool {
	a, ok := actual.(*NullLiteral)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	return true
}

func (p *NumberLiteral) match(actual any) bool {
	a, ok := actual.(*NumberLiteral)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Value == p.Value) {
		return false
	}
	if !((p.Raw == nil && a.Raw == nil) || (p.Raw != nil && a.Raw != nil && *a.Raw == *p.Raw)) {
		return false
	}
	return true
}

func (p *ObjectLiteral) match(actual any) bool {
	a, ok := actual.(*ObjectLiteral)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchProperties(a.Value, p.Value)) {
		return false
	}
	return true
}

func (p *ObjectPattern) match(actual any) bool {
	a, ok := actual.(*ObjectPattern)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchProperties(a.Properties, p.Properties)) {
		return false
	}
	if !(Match(a.Rest, p.Rest)) {
		return false
	}
	return true
}

func (p *Optional) match(actual any) bool {
	a, ok := actual.(*Optional)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Expr == nil && a.Expr == nil) || (p.Expr != nil && (p.Expr).match(a.Expr))) {
		return false
	}
	return true
}

func (p *OptionalChain) match(actual any) bool {
	a, ok := actual.(*OptionalChain)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Base == nil && a.Base == nil) || (p.Base != nil && (p.Base).match(a.Base))) {
		return false
	}
	return true
}

func (p *ParameterList) match(actual any) bool {
	a, ok := actual.(*ParameterList)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchVariableDeclarators(a.List, p.List)) {
		return false
	}
	if !(Match(a.Rest, p.Rest)) {
		return false
	}
	return true
}

func (p *PrivateDotExpression) match(actual any) bool {
	a, ok := actual.(*PrivateDotExpression)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Left == nil && a.Left == nil) || (p.Left != nil && (p.Left).match(a.Left))) {
		return false
	}
	if !((p.Identifier == nil && a.Identifier == nil) || (p.Identifier != nil && (p.Identifier).match(a.Identifier))) {
		return false
	}
	return true
}

func (p *PrivateIdentifier) match(actual any) bool {
	a, ok := actual.(*PrivateIdentifier)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Identifier == nil && a.Identifier == nil) || (p.Identifier != nil && (p.Identifier).match(a.Identifier))) {
		return false
	}
	return true
}

func (p *Program) match(actual any) bool {
	a, ok := actual.(*Program)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchStatements(a.Body, p.Body)) {
		return false
	}
	return true
}

func (p *Property) match(actual any) bool {
	a, ok := actual.(*Property)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(Match(a.Prop, p.Prop)) {
		return false
	}
	return true
}

func (p *PropertyKeyed) match(actual any) bool {
	a, ok := actual.(*PropertyKeyed)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Key == nil && a.Key == nil) || (p.Key != nil && (p.Key).match(a.Key))) {
		return false
	}
	if !(a.Kind == p.Kind) {
		return false
	}
	if !((p.Value == nil && a.Value == nil) || (p.Value != nil && (p.Value).match(a.Value))) {
		return false
	}
	if !(a.Computed == p.Computed) {
		return false
	}
	return true
}

func (p *PropertyShort) match(actual any) bool {
	a, ok := actual.(*PropertyShort)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Name == nil && a.Name == nil) || (p.Name != nil && (p.Name).match(a.Name))) {
		return false
	}
	if !((p.Initializer == nil && a.Initializer == nil) || (p.Initializer != nil && (p.Initializer).match(a.Initializer))) {
		return false
	}
	return true
}

func (p *RegExpLiteral) match(actual any) bool {
	a, ok := actual.(*RegExpLiteral)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Literal == p.Literal) {
		return false
	}
	if !(a.Pattern == p.Pattern) {
		return false
	}
	if !(a.Flags == p.Flags) {
		return false
	}
	return true
}

func (p *ReturnStatement) match(actual any) bool {
	a, ok := actual.(*ReturnStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Argument == nil && a.Argument == nil) || (p.Argument != nil && (p.Argument).match(a.Argument))) {
		return false
	}
	return true
}

func (p *SequenceExpression) match(actual any) bool {
	a, ok := actual.(*SequenceExpression)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(matchExpressions(a.Sequence, p.Sequence)) {
		return false
	}
	return true
}

func (p *SpreadElement) match(actual any) bool {
	a, ok := actual.(*SpreadElement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Expression == nil && a.Expression == nil) || (p.Expression != nil && (p.Expression).match(a.Expression))) {
		return false
	}
	return true
}

func (p *Statement) match(actual any) bool {
	a, ok := actual.(*Statement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(Match(a.Stmt, p.Stmt)) {
		return false
	}
	return true
}

func (p *StringLiteral) match(actual any) bool {
	a, ok := actual.(*StringLiteral)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Value == p.Value) {
		return false
	}
	if !((p.Raw == nil && a.Raw == nil) || (p.Raw != nil && a.Raw != nil && *a.Raw == *p.Raw)) {
		return false
	}
	return true
}

func (p *SuperExpression) match(actual any) bool {
	a, ok := actual.(*SuperExpression)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	return true
}

func (p *SwitchStatement) match(actual any) bool {
	a, ok := actual.(*SwitchStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Discriminant == nil && a.Discriminant == nil) || (p.Discriminant != nil && (p.Discriminant).match(a.Discriminant))) {
		return false
	}
	if !(a.Default == p.Default) {
		return false
	}
	if !(matchCaseStatements(a.Body, p.Body)) {
		return false
	}
	return true
}

func (p *TemplateElement) match(actual any) bool {
	a, ok := actual.(*TemplateElement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Literal == p.Literal) {
		return false
	}
	if !(a.Parsed == p.Parsed) {
		return false
	}
	if !(a.Valid == p.Valid) {
		return false
	}
	return true
}

func (p *TemplateLiteral) match(actual any) bool {
	a, ok := actual.(*TemplateLiteral)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Tag == nil && a.Tag == nil) || (p.Tag != nil && (p.Tag).match(a.Tag))) {
		return false
	}
	if !(matchTemplateElements(a.Elements, p.Elements)) {
		return false
	}
	if !(matchExpressions(a.Expressions, p.Expressions)) {
		return false
	}
	return true
}

func (p *ThisExpression) match(actual any) bool {
	a, ok := actual.(*ThisExpression)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	return true
}

func (p *ThrowStatement) match(actual any) bool {
	a, ok := actual.(*ThrowStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Argument == nil && a.Argument == nil) || (p.Argument != nil && (p.Argument).match(a.Argument))) {
		return false
	}
	return true
}

func (p *TryStatement) match(actual any) bool {
	a, ok := actual.(*TryStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Body == nil && a.Body == nil) || (p.Body != nil && (p.Body).match(a.Body))) {
		return false
	}
	if !((p.Catch == nil && a.Catch == nil) || (p.Catch != nil && (p.Catch).match(a.Catch))) {
		return false
	}
	if !((p.Finally == nil && a.Finally == nil) || (p.Finally != nil && (p.Finally).match(a.Finally))) {
		return false
	}
	return true
}

func (p *UnaryExpression) match(actual any) bool {
	a, ok := actual.(*UnaryExpression)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Operator == p.Operator) {
		return false
	}
	if !((p.Operand == nil && a.Operand == nil) || (p.Operand != nil && (p.Operand).match(a.Operand))) {
		return false
	}
	return true
}

func (p *UpdateExpression) match(actual any) bool {
	a, ok := actual.(*UpdateExpression)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Operator == p.Operator) {
		return false
	}
	if !((p.Operand == nil && a.Operand == nil) || (p.Operand != nil && (p.Operand).match(a.Operand))) {
		return false
	}
	if !(a.Postfix == p.Postfix) {
		return false
	}
	return true
}

func (p *VariableDeclaration) match(actual any) bool {
	a, ok := actual.(*VariableDeclaration)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !(a.Token == p.Token) {
		return false
	}
	if !(matchVariableDeclarators(a.List, p.List)) {
		return false
	}
	if !(a.Comment == p.Comment) {
		return false
	}
	return true
}

func (p *VariableDeclarator) match(actual any) bool {
	a, ok := actual.(*VariableDeclarator)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Target == nil && a.Target == nil) || (p.Target != nil && (p.Target).match(a.Target))) {
		return false
	}
	if !((p.Initializer == nil && a.Initializer == nil) || (p.Initializer != nil && (p.Initializer).match(a.Initializer))) {
		return false
	}
	return true
}

func (p *WhileStatement) match(actual any) bool {
	a, ok := actual.(*WhileStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Test == nil && a.Test == nil) || (p.Test != nil && (p.Test).match(a.Test))) {
		return false
	}
	if !((p.Body == nil && a.Body == nil) || (p.Body != nil && (p.Body).match(a.Body))) {
		return false
	}
	return true
}

func (p *WithStatement) match(actual any) bool {
	a, ok := actual.(*WithStatement)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Object == nil && a.Object == nil) || (p.Object != nil && (p.Object).match(a.Object))) {
		return false
	}
	if !((p.Body == nil && a.Body == nil) || (p.Body != nil && (p.Body).match(a.Body))) {
		return false
	}
	return true
}

func (p *YieldExpression) match(actual any) bool {
	a, ok := actual.(*YieldExpression)
	if !ok {
		return false
	}
	if p == nil {
		return a == nil
	}
	if a == nil {
		return false
	}
	if !((p.Argument == nil && a.Argument == nil) || (p.Argument != nil && (p.Argument).match(a.Argument))) {
		return false
	}
	if !(a.Delegate == p.Delegate) {
		return false
	}
	return true
}
