//go:build ignore

package main

import (
	"bytes"
	"cmp"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"log"
	"os"
	"slices"
)

// Generates visit.go

type NodeType int

const (
	NodeTypeStruct NodeType = iota
	NodeTypeSlice
)

type CloneableNodeType struct {
	Type     NodeType
	Name     string
	Children []Child
}

type Child struct {
	FieldName string
	Cloneable bool
	Pointer   bool
}

func newChild(fieldName string, cloneable, pointer bool) Child {
	return Child{FieldName: fieldName, Cloneable: cloneable, Pointer: pointer}
}

func main() {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, "./ast", func(info fs.FileInfo) bool {
		return info.Name() != "clone.go" && info.Name() != "visit.go"
	}, parser.ParseComments)
	if err != nil {
		log.Fatalf("%v", err)
	}

	var nodes []CloneableNodeType
	for _, file := range pkgs["ast"].Files {
		nodes = append(nodes, findCloneableNodes(file)...)
	}

	slices.SortFunc(nodes, func(a, b CloneableNodeType) int {
		return cmp.Compare(a.Name, b.Name)
	})
	fmt.Println(nodes)

	var (
		visitMethods []ast.Decl
	)
	for _, node := range nodes {
		recv := newFieldList("n", &ast.StarExpr{X: ast.NewIdent(node.Name)})
		visitChildrenBlock := &ast.BlockStmt{}

		var fields []ast.Expr
		switch node.Type {
		case NodeTypeStruct:
			for _, child := range node.Children {
				if !child.Cloneable {
					fields = append(fields, &ast.KeyValueExpr{
						Key:   ast.NewIdent(child.FieldName),
						Value: newSelectorExpr(ast.NewIdent("n"), child.FieldName),
					})
					continue
				}
				if child.Pointer {
					fields = append(fields, &ast.KeyValueExpr{
						Key: ast.NewIdent(child.FieldName),
						Value: &ast.CallExpr{
							Fun: newSelectorExpr(
								newSelectorExpr(ast.NewIdent("n"), child.FieldName),
								"Clone",
							),
						},
					})
					continue
				}
				fields = append(fields, &ast.KeyValueExpr{
					Key: ast.NewIdent(child.FieldName),
					Value: &ast.CallExpr{
						Fun: newSelectorExpr(
							newSelectorExpr(ast.NewIdent("n"), child.FieldName),
							"Clone",
						),
					},
				})
			}

			visitChildrenBlock.List = append(visitChildrenBlock.List, &ast.ReturnStmt{
				Results: []ast.Expr{
					&ast.UnaryExpr{Op: token.AND, X: &ast.CompositeLit{
						Type: ast.NewIdent(node.Name),
						Elts: fields,
					}},
				},
			})
		case NodeTypeSlice:
			// for i := range *n {
			//     (*n)[i].VisitWith(v)
			// }
			visitChildrenBlock.List = append(visitChildrenBlock.List, &ast.AssignStmt{
				Lhs: []ast.Expr{ast.NewIdent("ns")},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{&ast.CallExpr{
					Fun: ast.NewIdent("make"),
					Args: []ast.Expr{ast.NewIdent(node.Name), &ast.CallExpr{
						Fun:  ast.NewIdent("len"),
						Args: []ast.Expr{&ast.StarExpr{X: ast.NewIdent("n")}},
					}},
				}},
			}, &ast.RangeStmt{
				Key: ast.NewIdent("i"),
				Tok: token.DEFINE,
				X:   &ast.StarExpr{X: ast.NewIdent("n")},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.AssignStmt{Lhs: []ast.Expr{&ast.IndexExpr{
							X:     &ast.Ident{Name: "ns"},
							Index: ast.NewIdent("i"),
						}}, Tok: token.ASSIGN, Rhs: []ast.Expr{&ast.StarExpr{X: &ast.CallExpr{
							Fun: newSelectorExpr(&ast.IndexExpr{
								X:     &ast.StarExpr{X: ast.NewIdent("n")},
								Index: ast.NewIdent("i"),
							}, "Clone"),
						}}}},
					},
				},
			}, &ast.ReturnStmt{
				Results: []ast.Expr{
					&ast.UnaryExpr{Op: token.AND, X: ast.NewIdent("ns")},
				},
			})
		}

		visitMethods = append(visitMethods, &ast.FuncDecl{
			Recv: recv,
			Name: ast.NewIdent("Clone"),
			Type: &ast.FuncType{Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.StarExpr{X: &ast.Ident{Name: node.Name}},
					},
				},
			}},
			Body: visitChildrenBlock,
		})
	}

	genPkg := &ast.File{
		Name: ast.NewIdent("ast"),
	}

	genPkg.Decls = append(genPkg.Decls, visitMethods...)

	s := bytes.NewBuffer([]byte("// Code generated by gen_clone.go; DO NOT EDIT.\n"))
	format.Node(s, fset, genPkg)

	os.WriteFile("ast/clone.go", s.Bytes(), 0644)

	fmt.Println(pkgs)
}

func findCloneableNodes(f *ast.File) (types []CloneableNodeType) {
	for _, decl := range f.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			switch typeSpec.Name.Name {
			case "ScopeContext", "Id":
				continue
			}

			switch t := typeSpec.Type.(type) {
			case *ast.StructType:
				types = append(types, CloneableNodeType{
					Type:     NodeTypeStruct,
					Name:     typeSpec.Name.Name,
					Children: findStructChildren(t.Fields.List),
				})
			case *ast.ArrayType:
				types = append(types, CloneableNodeType{
					Type: NodeTypeSlice,
					Name: typeSpec.Name.Name,
				})
			}
		}
	}
	return types
}

func findStructChildren(fields []*ast.Field) (children []Child) {
	for _, field := range fields {
		if len(field.Names) != 0 {
			fmt.Println(field.Names[0].Name)
		}

		switch fieldType := field.Type.(type) {
		case *ast.SelectorExpr:
			children = append(children, newChild(field.Names[0].Name, false, false))
		case *ast.Ident:
			if len(field.Names) == 0 {
				children = append(children, newChild(fieldType.Name, true, false))
				continue
			}

			switch fieldType.Name {
			case "Idx", "any", "bool", "int", "ScopeContext", "string", "PropertyKind", "Token":
				children = append(children, newChild(field.Names[0].Name, false, false))
			default:
				children = append(children, newChild(field.Names[0].Name, true, false))
			}
		case *ast.StarExpr:
			children = append(children, newChild(field.Names[0].Name, true, true))
		}
	}
	return children
}

func newFieldList(name string, t ast.Expr) *ast.FieldList {
	return &ast.FieldList{
		List: []*ast.Field{{
			Names: []*ast.Ident{ast.NewIdent(name)},
			Type:  t,
		}},
	}
}

func newSelectorExpr(x ast.Expr, sel string) *ast.SelectorExpr {
	return &ast.SelectorExpr{X: x, Sel: ast.NewIdent(sel)}
}
