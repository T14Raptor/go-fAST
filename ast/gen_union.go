//go:build ignore

package main

import (
	"bytes"
	"cmp"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"log"
	"os"
	"slices"
	"strings"
)

type UnionConfig struct {
	WrapperType    string
	KindType       string
	KindPrefix     string
	ConstructorSfx string
	Variants       []Variant
}

type Variant struct {
	TypeName  string
	ShortName string
}

var shortNameOverrides = map[string]string{
	"OptionalChain":    "OptChain",
	"Expression":       "Expr",
	"Statement":        "Stmt",
	"PropertyKeyed":    "Keyed",
	"PropertyShort":    "Short",
	"ComputedProperty": "Computed",
	"ClassStaticBlock": "StaticBlock",
	"FieldDefinition":  "Field",
	"MethodDefinition": "Method",
}

func main() {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, "./ast", func(info fs.FileInfo) bool {
		name := info.Name()
		return name != "union.go" && name != "visit.go" && name != "clone.go"
	}, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	unions := findUnions(pkgs["ast"])

	var buf bytes.Buffer
	fmt.Fprintln(&buf, "// Code generated by gen_union.go; DO NOT EDIT.")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "package ast")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, `import "unsafe"`)
	fmt.Fprintln(&buf)

	for _, u := range unions {
		generateUnion(&buf, u)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		os.WriteFile("ast/union.go", buf.Bytes(), 0644)
		log.Fatalf("format error: %v", err)
	}

	if err := os.WriteFile("ast/union.go", formatted, 0644); err != nil {
		log.Fatal(err)
	}
	fmt.Println("Generated ast/union.go")
}

// findUnions scans the package for structs with a //union:Variant1,Variant2,...
// doc comment and builds a UnionConfig for each one.
func findUnions(pkg *ast.Package) []UnionConfig {
	var unions []UnionConfig
	for _, file := range pkg.Files {
		for _, decl := range file.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.TYPE {
				continue
			}
			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				if _, ok := typeSpec.Type.(*ast.StructType); !ok {
					continue
				}
				variantList := parseUnionComment(typeSpec.Doc)
				if variantList == nil {
					continue
				}

				name := typeSpec.Name.Name
				kindPrefix, kindType, ctorSuffix := deriveUnionNames(name)

				var variants []Variant
				for _, typeName := range variantList {
					variants = append(variants, Variant{
						TypeName:  typeName,
						ShortName: deriveShortName(typeName),
					})
				}
				slices.SortFunc(variants, func(a, b Variant) int {
					return cmp.Compare(a.ShortName, b.ShortName)
				})

				unions = append(unions, UnionConfig{
					WrapperType:    name,
					KindType:       kindType,
					KindPrefix:     kindPrefix,
					ConstructorSfx: ctorSuffix,
					Variants:       variants,
				})
			}
		}
	}
	return unions
}

// parseUnionComment looks for a //union:Type1,Type2,... comment and returns
// the type name list, or nil if no such comment exists.
func parseUnionComment(doc *ast.CommentGroup) []string {
	if doc == nil {
		return nil
	}
	for _, c := range doc.List {
		text := strings.TrimSpace(strings.TrimPrefix(c.Text, "//"))
		if strings.HasPrefix(text, "union:") {
			raw := strings.TrimPrefix(text, "union:")
			var names []string
			for _, name := range strings.Split(raw, ",") {
				name = strings.TrimSpace(name)
				if name != "" {
					names = append(names, name)
				}
			}
			return names
		}
	}
	return nil
}

// deriveUnionNames produces the KindPrefix, KindType, and ConstructorSuffix
// from the union wrapper type name.
func deriveUnionNames(name string) (kindPrefix, kindType, ctorSuffix string) {
	switch name {
	case "Expression":
		return "Expr", "ExprKind", "Expr"
	case "Statement":
		return "Stmt", "StmtKind", "Stmt"
	case "Property":
		return "Prop", "PropKind", "Prop"
	case "MemberProperty":
		return "MemProp", "MemPropKind", "MemProp"
	case "ForLoopInitializer":
		return "ForInit", "ForInitKind", "ForInit"
	case "ClassElement":
		return "ClassElem", "ClassElemKind", "ClassElem"
	default:
		return name, name + "Kind", name
	}
}

func deriveShortName(typeName string) string {
	if override, ok := shortNameOverrides[typeName]; ok {
		return override
	}

	name := typeName

	switch {
	case strings.HasSuffix(name, "Expression"):
		name = strings.TrimSuffix(name, "Expression")
	case strings.HasSuffix(name, "Statement"):
		name = strings.TrimSuffix(name, "Statement")
	case strings.HasSuffix(name, "Literal"):
		name = strings.TrimSuffix(name, "Literal") + "Lit"
	case strings.HasSuffix(name, "Declaration"):
		name = strings.TrimSuffix(name, "Declaration") + "Decl"
	case strings.HasSuffix(name, "Element"):
		name = strings.TrimSuffix(name, "Element")
	case strings.HasSuffix(name, "Pattern"):
		name = strings.TrimSuffix(name, "Pattern") + "Pat"
	}

	abbreviations := [][2]string{
		{"ArrowFunction", "ArrowFunc"},
		{"Identifier", "Ident"},
		{"Function", "Func"},
		{"Variable", "Var"},
		{"Property", "Prop"},
		{"Template", "Tmpl"},
		{"Private", "Priv"},
		{"Boolean", "Bool"},
		{"Number", "Num"},
		{"String", "Str"},
		{"Object", "Obj"},
		{"Array", "Arr"},
	}
	for _, ab := range abbreviations {
		name = strings.ReplaceAll(name, ab[0], ab[1])
	}

	return name
}

func generateUnion(buf *bytes.Buffer, u UnionConfig) {
	fmt.Fprintf(buf, "// ---- %s tagged union ----\n\n", u.WrapperType)

	fmt.Fprintf(buf, "type %s uint8\n\n", u.KindType)
	fmt.Fprintf(buf, "const (\n")
	fmt.Fprintf(buf, "\t%sNone %s = iota\n", u.KindPrefix, u.KindType)
	for _, v := range u.Variants {
		fmt.Fprintf(buf, "\t%s%s\n", u.KindPrefix, v.ShortName)
	}
	fmt.Fprintf(buf, ")\n\n")

	fmt.Fprintf(buf, "func (k %s) String() string {\n", u.KindType)
	fmt.Fprintf(buf, "\tswitch k {\n")
	fmt.Fprintf(buf, "\tcase %sNone:\n\t\treturn \"%sNone\"\n", u.KindPrefix, u.KindPrefix)
	for _, v := range u.Variants {
		fmt.Fprintf(buf, "\tcase %s%s:\n\t\treturn \"%s%s\"\n", u.KindPrefix, v.ShortName, u.KindPrefix, v.ShortName)
	}
	fmt.Fprintf(buf, "\t}\n")
	fmt.Fprintf(buf, "\treturn \"%s(?)\"\n", u.KindType)
	fmt.Fprintf(buf, "}\n\n")

	fmt.Fprintf(buf, "func (n *%s) Kind() %s { return n.kind }\n", u.WrapperType, u.KindType)
	fmt.Fprintf(buf, "func (n *%s) IsNone() bool { return n.kind == %sNone }\n\n", u.WrapperType, u.KindPrefix)

	for _, v := range u.Variants {
		fmt.Fprintf(buf, "func New%s%s(n *%s) %s {\n", v.ShortName, u.ConstructorSfx, v.TypeName, u.WrapperType)
		fmt.Fprintf(buf, "\treturn %s{kind: %s%s, ptr: unsafe.Pointer(n)}\n", u.WrapperType, u.KindPrefix, v.ShortName)
		fmt.Fprintf(buf, "}\n\n")

		fmt.Fprintf(buf, "func (n *%s) %s() (*%s, bool) {\n", u.WrapperType, v.ShortName, v.TypeName)
		fmt.Fprintf(buf, "\tif n.kind == %s%s {\n", u.KindPrefix, v.ShortName)
		fmt.Fprintf(buf, "\t\treturn (*%s)(n.ptr), true\n", v.TypeName)
		fmt.Fprintf(buf, "\t}\n")
		fmt.Fprintf(buf, "\treturn nil, false\n")
		fmt.Fprintf(buf, "}\n\n")

		fmt.Fprintf(buf, "func (n *%s) Must%s() *%s {\n", u.WrapperType, v.ShortName, v.TypeName)
		fmt.Fprintf(buf, "\tif n.kind != %s%s {\n", u.KindPrefix, v.ShortName)
		fmt.Fprintf(buf, "\t\tpanic(\"unexpected kind: \" + n.kind.String())\n")
		fmt.Fprintf(buf, "\t}\n")
		fmt.Fprintf(buf, "\treturn (*%s)(n.ptr)\n", v.TypeName)
		fmt.Fprintf(buf, "}\n\n")

		fmt.Fprintf(buf, "func (n *%s) Is%s() bool {\n", u.WrapperType, v.ShortName)
		fmt.Fprintf(buf, "\treturn n.kind == %s%s\n", u.KindPrefix, v.ShortName)
		fmt.Fprintf(buf, "}\n\n")
	}

	fmt.Fprintf(buf, "func (n *%s) Idx0() Idx {\n", u.WrapperType)
	fmt.Fprintf(buf, "\tswitch n.kind {\n")
	for _, v := range u.Variants {
		fmt.Fprintf(buf, "\tcase %s%s:\n", u.KindPrefix, v.ShortName)
		fmt.Fprintf(buf, "\t\treturn (*%s)(n.ptr).Idx0()\n", v.TypeName)
	}
	fmt.Fprintf(buf, "\t}\n")
	fmt.Fprintf(buf, "\treturn 0\n")
	fmt.Fprintf(buf, "}\n\n")

	fmt.Fprintf(buf, "func (n *%s) Idx1() Idx {\n", u.WrapperType)
	fmt.Fprintf(buf, "\tswitch n.kind {\n")
	for _, v := range u.Variants {
		fmt.Fprintf(buf, "\tcase %s%s:\n", u.KindPrefix, v.ShortName)
		fmt.Fprintf(buf, "\t\treturn (*%s)(n.ptr).Idx1()\n", v.TypeName)
	}
	fmt.Fprintf(buf, "\t}\n")
	fmt.Fprintf(buf, "\treturn 0\n")
	fmt.Fprintf(buf, "}\n\n")

	fmt.Fprintf(buf, "func (n *%s) Unwrap() VisitableNode {\n", u.WrapperType)
	fmt.Fprintf(buf, "\tif n == nil { return nil }\n")
	fmt.Fprintf(buf, "\tswitch n.kind {\n")
	for _, v := range u.Variants {
		fmt.Fprintf(buf, "\tcase %s%s:\n", u.KindPrefix, v.ShortName)
		fmt.Fprintf(buf, "\t\treturn (*%s)(n.ptr)\n", v.TypeName)
	}
	fmt.Fprintf(buf, "\t}\n")
	fmt.Fprintf(buf, "\treturn nil\n")
	fmt.Fprintf(buf, "}\n\n")
}
