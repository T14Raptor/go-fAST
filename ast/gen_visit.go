//go:build ignore

package main

import (
	"bytes"
	"cmp"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"log"
	"os"
	"slices"
	"strings"
)

type NodeType int

const (
	NodeTypeStruct NodeType = iota
	NodeTypeSlice
)

type VisitableNodeType struct {
	Type     NodeType
	Name     string
	Children []Child

	IsUnion    bool
	Variants   []UnionVariant
	KindPrefix string
}

type UnionVariant struct {
	TypeName  string
	ShortName string
}

type Child struct {
	FieldName string
	Optional  bool
}

func newChild(fieldName string, optional bool) Child {
	return Child{FieldName: fieldName, Optional: optional}
}

func main() {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, "./ast", func(info fs.FileInfo) bool {
		return info.Name() != "visit.go"
	}, parser.ParseComments)
	if err != nil {
		log.Fatalf("%v", err)
	}

	var nodes []VisitableNodeType
	for _, file := range pkgs["ast"].Files {
		nodes = append(nodes, findVisitableNodes(file)...)
	}

	slices.SortFunc(nodes, func(a, b VisitableNodeType) int {
		return cmp.Compare(a.Name, b.Name)
	})
	fmt.Println(nodes)

	var (
		visitorMethods     []*ast.Field
		noopVisitorMethods []ast.Decl
		visitMethods       []ast.Decl
	)
	for _, node := range nodes {
		visitorMethods = append(visitorMethods, &ast.Field{
			Names: []*ast.Ident{{Name: "Visit" + node.Name}},
			Type: &ast.FuncType{
				Params: newFieldList("n", &ast.StarExpr{X: ast.NewIdent(node.Name)}),
			},
		})

		noopVisitorMethods = append(noopVisitorMethods, &ast.FuncDecl{
			Recv: newFieldList("nv", &ast.StarExpr{X: ast.NewIdent("NoopVisitor")}),
			Name: ast.NewIdent("Visit" + node.Name),
			Type: &ast.FuncType{
				Params: newFieldList("n", &ast.StarExpr{X: ast.NewIdent(node.Name)}),
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ExprStmt{X: &ast.CallExpr{
						Fun:  newSelectorExpr(ast.NewIdent("n"), "VisitChildrenWith"),
						Args: []ast.Expr{newSelectorExpr(ast.NewIdent("nv"), "V")},
					}},
				},
			},
		})

		if node.IsUnion {
			continue
		}

		recv := newFieldList("n", &ast.StarExpr{X: ast.NewIdent(node.Name)})
		params := newFieldList("v", ast.NewIdent("Visitor"))
		visitChildrenBlock := &ast.BlockStmt{}
		switch node.Type {
		case NodeTypeStruct:
			for _, child := range node.Children {
				callExpr := &ast.ExprStmt{X: &ast.CallExpr{
					Fun: newSelectorExpr(
						newSelectorExpr(ast.NewIdent("n"), child.FieldName),
						"VisitWith",
					),
					Args: []ast.Expr{ast.NewIdent("v")},
				}}
				if child.Optional {
					visitChildrenBlock.List = append(visitChildrenBlock.List, &ast.IfStmt{
						Cond: &ast.BinaryExpr{
							X:  newSelectorExpr(ast.NewIdent("n"), child.FieldName),
							Op: token.NEQ,
							Y:  ast.NewIdent("nil"),
						},
						Body: &ast.BlockStmt{List: []ast.Stmt{callExpr}},
					})
				} else {
					visitChildrenBlock.List = append(visitChildrenBlock.List, callExpr)
				}
			}
		case NodeTypeSlice:
			visitChildrenBlock.List = append(visitChildrenBlock.List, &ast.ForStmt{
				Init: &ast.AssignStmt{
					Lhs: []ast.Expr{ast.NewIdent("i")},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{&ast.BasicLit{Value: "0"}},
				},
				Cond: &ast.BinaryExpr{
					X:  ast.NewIdent("i"),
					Op: token.LSS,
					Y: &ast.CallExpr{
						Fun:  ast.NewIdent("len"),
						Args: []ast.Expr{&ast.StarExpr{X: ast.NewIdent("n")}},
					},
				},
				Post: &ast.IncDecStmt{
					X:   ast.NewIdent("i"),
					Tok: token.INC,
				},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.ExprStmt{X: &ast.CallExpr{
							Fun: newSelectorExpr(&ast.IndexExpr{
								X:     &ast.StarExpr{X: ast.NewIdent("n")},
								Index: ast.NewIdent("i"),
							}, "VisitWith"),
							Args: []ast.Expr{ast.NewIdent("v")},
						}},
					},
				},
			})
		}
		visitMethods = append(visitMethods, &ast.FuncDecl{
			Recv: recv,
			Name: ast.NewIdent("VisitWith"),
			Type: &ast.FuncType{Params: params},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ExprStmt{X: &ast.CallExpr{
						Fun:  newSelectorExpr(ast.NewIdent("v"), "Visit"+node.Name),
						Args: []ast.Expr{ast.NewIdent("n")},
					}},
				},
			},
		}, &ast.FuncDecl{
			Recv: recv,
			Name: ast.NewIdent("VisitChildrenWith"),
			Type: &ast.FuncType{Params: params},
			Body: visitChildrenBlock,
		})
	}

	genPkg := &ast.File{
		Name: ast.NewIdent("ast"),
		Decls: []ast.Decl{
			&ast.GenDecl{
				Tok: token.TYPE,
				Specs: []ast.Spec{
					&ast.TypeSpec{
						Name: ast.NewIdent("Visitor"),
						Type: &ast.InterfaceType{
							Methods: &ast.FieldList{List: visitorMethods},
						},
					},
				},
			},
			&ast.GenDecl{
				Tok: token.TYPE,
				Specs: []ast.Spec{
					&ast.TypeSpec{
						Name: ast.NewIdent("NoopVisitor"),
						Type: &ast.StructType{
							Fields: newFieldList("V", ast.NewIdent("Visitor")),
						},
					},
				},
			},
		},
	}

	genPkg.Decls = append(genPkg.Decls, noopVisitorMethods...)
	genPkg.Decls = append(genPkg.Decls, visitMethods...)

	s := bytes.NewBuffer([]byte("// Code generated by gen_visit.go; DO NOT EDIT.\n"))
	format.Node(s, fset, genPkg)

	for _, node := range nodes {
		if !node.IsUnion {
			continue
		}
		generateUnionVisit(s, node)
	}

	formatted, err := format.Source(s.Bytes())
	if err != nil {
		os.WriteFile("ast/visit.go", s.Bytes(), 0644)
		log.Fatalf("format error: %v", err)
	}

	os.WriteFile("ast/visit.go", formatted, 0644)

	fmt.Println(pkgs)
}

func generateUnionVisit(buf *bytes.Buffer, node VisitableNodeType) {
	fmt.Fprintf(buf, "\nfunc (n *%s) VisitWith(v Visitor) {\n", node.Name)
	fmt.Fprintf(buf, "\tif n == nil { return }\n")
	fmt.Fprintf(buf, "\tv.Visit%s(n)\n", node.Name)
	fmt.Fprintf(buf, "}\n\n")

	fmt.Fprintf(buf, "func (n *%s) VisitChildrenWith(v Visitor) {\n", node.Name)
	fmt.Fprintf(buf, "\tif n == nil { return }\n")
	fmt.Fprintf(buf, "\tswitch n.kind {\n")
	for _, v := range node.Variants {
		fmt.Fprintf(buf, "\tcase %s%s:\n", node.KindPrefix, v.ShortName)
		fmt.Fprintf(buf, "\t\t(*%s)(n.ptr).VisitWith(v)\n", v.TypeName)
	}
	fmt.Fprintf(buf, "\t}\n")
	fmt.Fprintf(buf, "}\n\n")
}

func findVisitableNodes(f *ast.File) (types []VisitableNodeType) {
	for _, decl := range f.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			switch typeSpec.Name.Name {
			case "ScopeContext", "Id":
				continue
			}

			switch t := typeSpec.Type.(type) {
			case *ast.StructType:
				node := VisitableNodeType{
					Type:     NodeTypeStruct,
					Name:     typeSpec.Name.Name,
					Children: findStructChildren(t.Fields.List),
				}
				if variantList := parseUnionComment(typeSpec.Doc); variantList != nil {
					kindPrefix, _, _ := deriveUnionNames(typeSpec.Name.Name)
					var variants []UnionVariant
					for _, typeName := range variantList {
						variants = append(variants, UnionVariant{
							TypeName:  typeName,
							ShortName: deriveShortName(typeName),
						})
					}
					slices.SortFunc(variants, func(a, b UnionVariant) int {
						return cmp.Compare(a.ShortName, b.ShortName)
					})
					node.IsUnion = true
					node.Variants = variants
					node.KindPrefix = kindPrefix
				}
				types = append(types, node)
			case *ast.ArrayType:
				types = append(types, VisitableNodeType{
					Type: NodeTypeSlice,
					Name: typeSpec.Name.Name,
				})
			}
		}
	}
	return types
}

func findStructChildren(fields []*ast.Field) (children []Child) {
	for _, field := range fields {
		optional := field.Tag != nil && field.Tag.Value == "`optional:\"true\"`"

		if len(field.Names) != 0 {
			fmt.Println(field.Names[0].Name)
		}

		switch fieldType := field.Type.(type) {
		case *ast.Ident:
			if len(field.Names) == 0 {
				children = append(children, newChild(fieldType.Name, optional))
				continue
			}

			switch fieldType.Name {
			case "Idx", "any", "bool", "int", "ScopeContext", "string", "PropertyKind", "float64":
			default:
				fmt.Println(fieldType.Name)
				children = append(children, newChild(field.Names[0].Name, optional))
			}
		case *ast.StarExpr:
			if ident, ok := fieldType.X.(*ast.Ident); ok && ident.Name == "string" {
				continue
			}
			children = append(children, newChild(field.Names[0].Name, optional))
		}
	}
	return children
}

func newFieldList(name string, t ast.Expr) *ast.FieldList {
	return &ast.FieldList{
		List: []*ast.Field{{
			Names: []*ast.Ident{ast.NewIdent(name)},
			Type:  t,
		}},
	}
}

func newSelectorExpr(x ast.Expr, sel string) *ast.SelectorExpr {
	return &ast.SelectorExpr{X: x, Sel: ast.NewIdent(sel)}
}

func parseUnionComment(doc *ast.CommentGroup) []string {
	if doc == nil {
		return nil
	}
	for _, c := range doc.List {
		text := strings.TrimSpace(strings.TrimPrefix(c.Text, "//"))
		if strings.HasPrefix(text, "union:") {
			raw := strings.TrimPrefix(text, "union:")
			var names []string
			for _, name := range strings.Split(raw, ",") {
				name = strings.TrimSpace(name)
				if name != "" {
					names = append(names, name)
				}
			}
			return names
		}
	}
	return nil
}

func deriveUnionNames(name string) (kindPrefix, kindType, ctorSuffix string) {
	switch name {
	case "Expression":
		return "Expr", "ExprKind", "Expr"
	case "Statement":
		return "Stmt", "StmtKind", "Stmt"
	case "Property":
		return "Prop", "PropKind", "Prop"
	case "MemberProperty":
		return "MemProp", "MemPropKind", "MemProp"
	case "ForLoopInitializer":
		return "ForInit", "ForInitKind", "ForInit"
	case "ClassElement":
		return "ClassElem", "ClassElemKind", "ClassElem"
	default:
		return name, name + "Kind", name
	}
}

var shortNameOverrides = map[string]string{
	"OptionalChain":    "OptChain",
	"Expression":       "Expr",
	"Statement":        "Stmt",
	"PropertyKeyed":    "Keyed",
	"PropertyShort":    "Short",
	"ComputedProperty": "Computed",
	"ClassStaticBlock": "StaticBlock",
	"FieldDefinition":  "Field",
	"MethodDefinition": "Method",
}

func deriveShortName(typeName string) string {
	if override, ok := shortNameOverrides[typeName]; ok {
		return override
	}

	name := typeName

	switch {
	case strings.HasSuffix(name, "Expression"):
		name = strings.TrimSuffix(name, "Expression")
	case strings.HasSuffix(name, "Statement"):
		name = strings.TrimSuffix(name, "Statement")
	case strings.HasSuffix(name, "Literal"):
		name = strings.TrimSuffix(name, "Literal") + "Lit"
	case strings.HasSuffix(name, "Declaration"):
		name = strings.TrimSuffix(name, "Declaration") + "Decl"
	case strings.HasSuffix(name, "Element"):
		name = strings.TrimSuffix(name, "Element")
	case strings.HasSuffix(name, "Pattern"):
		name = strings.TrimSuffix(name, "Pattern") + "Pat"
	}

	abbreviations := [][2]string{
		{"ArrowFunction", "ArrowFunc"},
		{"Identifier", "Ident"},
		{"Function", "Func"},
		{"Variable", "Var"},
		{"Property", "Prop"},
		{"Template", "Tmpl"},
		{"Private", "Priv"},
		{"Boolean", "Bool"},
		{"Number", "Num"},
		{"String", "Str"},
		{"Object", "Obj"},
		{"Array", "Arr"},
	}
	for _, ab := range abbreviations {
		name = strings.ReplaceAll(name, ab[0], ab[1])
	}

	return name
}
